#!/usr/bin/env python
# coding: utf-8

# In[ ]:


# This Python 3 environment comes with many helpful analytics libraries installed
# It is defined by the kaggle/python docker image: https://github.com/kaggle/docker-python
# For example, here's several helpful packages to load in 

import numpy as np # linear algebra
import pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)

# Input data files are available in the "../input/" directory.
# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory

import os
for dirname, _, filenames in os.walk('/kaggle/input'):
    for filename in filenames:
        print(os.path.join(dirname, filename))

# Any results you write to the current directory are saved as output.

import sklearn.model_selection
import matplotlib.pyplot as plt
import seaborn as sb
import warnings
warnings.filterwarnings('ignore')  # change once to ignore when publishing 


# # Rituximab Data Analysis
# 
# ---
# 
# 
# 
# 
# 30/10/2019
# 
# 1. [Introduction](#Introduction)
#     - [About Rituximab](#Rit)
#     - [Flow Cytometry](#flow)
#     - [Gating](#gating)
#     - [Problem Definition](#def)
# 2. [Data](#Data)
#     - [Load Data](#Load Data)
#     - [Data Description](#description)
#     - [Clean Data](#clean)
#     - [Split Data](#split)
# 3. [Exploratory Data Analysis](#eda)
#     - [Variable Histograms](#hist)
#     - [Scatter Plots](#scatter)
#     - [Principal Component Analysis](#pca)
# 4. [Unsupervised Learning Models](#unsup)
#     - [K Means Clustering](#km)
#     - [Hierarchical Clustering](#hc)
# 5. [Supervised Classification Models](#sup)
#     - [K Nearest Neighbors](#knn)
#     - [Logistic Regression](#lr)
#     - [Decision Tree Classifier](#dt)
#     - [Multi Layer Perceptron](#mlp)
# 6. [Ensemble Methods](#em)
#     - [Bagging Methods](#bag)
#     - [Voting Classifier](#vote)
# 7. [Results](#res)
#     - [Misclassified points](#misclf)
# 8. [Conclusion](#conc)
#     
#     
#     

# <a id="Introduction"></a>
# ## 1. __Introduction__
# 
# ---
# <a id="Rit"></a>
# ### __About Rituximab__
# Rituximab is a medication used to treat certain types of cancer and autoimmune diseases such as non-Hodghkin's lymphoma, chronic lymphocytic leukemia and rheumatoid arthritis. It is a monoclonal antibody that targets the surface of leukaemia and lymphoma cells.Rituximab works by targeting a protein called CD20. It sticks to the CD20 proteins that it finds which allows the patient's immune system to target these cells and kill them. Rituximab primarily tends to affect the malignant B cells with the highest levels of CD20.
#  
#  <a id="flow"></a>
#  ### __Flow Cytometry__
# Originally developed in the 1960's flow cytometry is laser-based technology to analsye the characteristics of heterogenous cell populations. It used extensively in the life sciences as it as a particularly powerful method that allows researchers to quickly analyze cell populations in a liquid medium to identify, serparate and characterise different cell types. The researcher can simulataneously measure multiple parameters about single cells including cell size and cell volume. Different cell subpopulations can also be counted and sorted using this technique.
#  
# The cells are stained before entering the flow cytometer with flurophores which recognize a target feature on or in the cell. In a flow cytometer, a sample of cells that are suspended in a fluid are passed through a small nozzle. This produces a very thin stream of cells that travel past a laser beam, one cell at a time. The laser light is scattered by the cells and detected using insturments to measure forward scatter and side scatter which measure the amount of light that passes through the sample and the light that is scatter orthonal to the beam direction. The amount of scattering depends on the cell size and granuarity. Flourescence detectors also measure the flourescence emitted from the stained cells.
# 
# <a id="gating"></a>
# ### __Gating__
# The data generated by flow cytometers can be plotted in multiple dimensions. The regions on these plots can then be separated by creating a series of subset extractions. This process is called gating and is used to identify distinct populations of cells within a dataset. In summary, a gate or a region is a boundary drawn around a subpopulation to isolate events for analysis or sorting. The data points given in the Rituximab dataset are gated according to an unknown gating protocol.
# <a id="def"></a>
# ### __Problem Definition__
# The goal of this notebook is to come up with a model to classify a new data point as a particular gate (without knowing the underlying gate protocol) given it's measured values. 
# 

# <a id="Data"></a>
# ## 2. __Data__
# ---
# <a id="Load Data"></a>
# ### __Load Data__
# The dataset is loaded into a Dataframe from a CSV File. The first 15 values of the dataset are printed in a table below.
# 

# In[ ]:


from sklearn.metrics import accuracy_score

rituximab = pd.read_csv("../input/rituximab.csv")
rit=rituximab.copy()
rit.columns=['FSCH','SSCH','FL1H','FL2H','FL3H','FL1A','FL1W','Time','Gate']
rit.head(5)


# <a id="description"></a>
# 
# ## __Data Description__
# 
# -  __Scattering Parameters__
# The first two parameters (FSCH/SSCH) are measurements of the scattering of the laser beam in the laser beams direction and orthogonal to the laser beam's direction. The amount of scattering in the forward direction (FSCH) is dependent on the cell size.The scattering in the orthogonal direction is also dependent on the size of the cell but is additionally dependent on the cell's internal structure and it's membrane. These parameters can thus be simplified as measures of a cell's size (FSCH) and a cell's internal complexity (SSCH) however in reality this is not taking into account the full complexity of the problem.
# 
# -  __Flourescence Parameters__
# FL1H/FL2H/FL3H/FL1A/FL1W are flourescence parameters. When a fluorescent dye is conjugated to a monoclonal antibody, it can be used to identify a particular cell type based on the individual properties of the cell.In a mixed population of cells, different fluorochromes can be used to distinguish separate subpopulations and this is why multiple flourescence parameters are recorded. As the fluorescing cell passes through the laser beam, it creates a peak or pulse of photon emission over time. These are detected and converted to a voltage pulse, known as an event. The total pulse height and area is measured by the flow cytometer. The measured voltage pulse area will correlate directly to the intensity of fluorescence for that event. Each event is given a channel number depending on its measured intensity; the more intense the fluorescence, the higher the channel number the event is assigned.
# 
# 
# -  __Time__
# The time variable is not used in the analysis below but it can be used to detect physiological changes in cell populations when a given sample is analysed at different times. For example, it could detect the change in the proportion of healthy cells to malignant cells in time after a drug treatment has been applied.
# 
# -  __Gate__
# This is the label given to each cell by the researcher according to a specific gating protocol. The gating protocol used is an unknown.
# 
# 

# <a id="clean"></a>
# ## __Clean Data__
# 
# - In this data two gates have been identified and labelled as 1 and 2. These will now be relabelled as 0 and 1 respectively.Data points with a Gate labelled as -1 are deemed to be noisy data points and are discarded.
# - In the analysis below the Time variable will not be explored and is discarded. 
# - The dataset is also checked for null values.
# 
# 
# 
# 

# In[ ]:



rit1=rit.drop('Time',axis=1)
rit1=rit1[rit1['Gate']!=-1]
rit1.loc[:, "Gate"] = rit1.loc[:, "Gate"].map({1: 0, 2: 1})
print("The dataset contains ",rit1.isnull().sum().sum()," null values")
print('The first 10 elements of the cleaned dataset are shown below')
rit1.head(10)


# <a id="split"></a>
# ### __Split Data__
# The data is now split into a training set to find parameters for the models that are used and a test set which is used to test the ability of the models to generalise to unseen data. An 80/20 split is used in this case.
# 

# In[ ]:


from sklearn.model_selection import train_test_split
train_set, test_set = train_test_split(rit1, test_size=0.2, random_state=42)
train_labels=train_set.copy()['Gate']
test_labels=test_set.copy()['Gate']
test_no_labels=test_set.copy().drop('Gate',axis=1)
print('The train set has ',train_set.shape[0],' data points')
print('The test set has ',test_set.shape[0],' data points')



# <a id="eda"></a>
# ## __3. Exploratory Data Analysis__
# ---
# The data is now analysed with both graphical and descriptive statistics to look for  potential problems , patterns and correlations with the target variable (Gate).
# 
# 
# 

# <a id="hist"></a>
# ### __Variable Histograms__
# All of the histograms are positively skewed. Notably FL1H has a clear bimodal distibution which should be explored. Looking at the gate histogram above, approximately 850 data points are classified as gate 1 and approximately 200 are classified as gate 0. This means that if a extremely basic classification model is chosen where every input is assigned to Gate 0 then we would expect roughly $(\frac{850}{1099}*100)\% \approx 73\% $ accuracy. This is used as a minimum benchmark for any model that is analysed as a model with lesser accuracy than this is very poor.
# 

# In[ ]:




train_set.hist(bins=25, figsize=(20,15))

plt.show()


# <a id="scater"></a>
# ### __Scatter Plots__
# 
# 
# - __Scatter Matrix__
# 
# Below is a matrix of the scatter plots of all of the variables in our dataset. Some of the scatter plots show good sepration between the two gates which will be useful for analysis. In particular, it can now be seen that the two modes of the FL1H histogram correspond to the two different gates.The FL1H seems to be a very important parameter in the unknown gating protocol as there is a lot of separation between the gates in it's scatter plots. Also a non zero FL1A variable tends to correspend to the data point belonging to Gate 2.
# 
# 
# 
# 

# In[ ]:


ax=sb.pairplot(train_set,hue='Gate',plot_kws={'alpha': 0.3})
ax.fig.set_size_inches(20, 20);


# - __Scattering parameters__
# 
# It was mentioned above that the forward scattering parameter is related to the size of the cell and the side scattering parameter is related to the internal complexity of the cell. Seeing as different cell types may differ in size and internal structure, these parameters should help to differentiate between cells.
# 

# In[ ]:


fig,ax =plt.subplots()
fig.set_size_inches(11.7, 8.27)
ax = sb.scatterplot(x="FSCH", y="SSCH", hue="Gate",  data=train_set,alpha=0.3)
ax.set_title("Scattering Parameters");


# It appears there may be a relationship here as it appears for a given FSCH value, data points belonging to gate 1 tend to have a lower SSCH value than gate 2.
# 
# 
# - __FL1H Parameter__
# 

# In[ ]:


fig,ax =plt.subplots()
fig.set_size_inches(11.7, 8.27)
ax = sb.scatterplot(x="FL1H",y=1, hue="Gate",  data=train_set,alpha=0.3)
ax.set_title("FL1H Parameter");

ax.set_yticklabels([]);


# This scatter plot shows that the two modes of the histogram of the FL1H parameter correspond to the different gates. Data points belonging to gate 1 tend to have a higher FL1H parameter value than those of gate 2. This will be useful in a model classifying new data points.

# - __Correlation Matrix__
# 
# The correlation matrix is a graphical representation of the strength of the relationship between variables

# In[ ]:




#correlation matrix
corrmat = train_set.corr()
f, ax = plt.subplots(figsize=(12, 9))
sb.heatmap(corrmat, vmax=.8, square=True,cmap='YlGnBu');


# It can be seen from the correlation matrix that the FL1H parameter is indeed very important in determining what Gate a new data point will belong to. Also note that the SSCH variable has a very low correlation value with the gate variable and most other variables and so will probabbly be the least important variable in further analysis.

# In[ ]:


from sklearn.preprocessing import StandardScaler
from sklearn.decomposition import PCA
pca = PCA(n_components=3)
train_no_labels=train_set.drop('Gate',axis=1)
principalComponents = pca.fit_transform(train_no_labels)
principalDf = pd.DataFrame(data = principalComponents
             , columns = ['pc1', 'pc2','pc3'])
finalDf = pd.concat([principalDf, train_set['Gate']], axis = 1)

s=pca.explained_variance_ratio_.sum()


# <a id="pca"></a>
# ### __Principal Component Analysis__
# 
# 

# In[ ]:


print('The first 3 principal components explain',round(s*100,2),'% of the variance of the data')


# The scatter matrix of the first 3 Principal Components is plotted below. There isn't any clear separation shown in these scatter plots so the Principal Component Analysis will not be used directly in building a classification model.

# In[ ]:










ax=sb.pairplot(finalDf,hue='Gate',plot_kws={'alpha': 0.3},vars=['pc1','pc2','pc3'])
ax.fig.set_size_inches(20, 20)




# <a id="unsup"></a>
# ## __4. Unsupervised Learning Models__
# ---
# 
# The goal of the models presented in this section is to identify subsets of the training set which are similar to the identified gates using unlabelled data. For example, the scatter plot of the FL1H parameter with the Gate label shows that data points with label 0 tend to have an FL1H value of less than 400 and ones with label 1 tend to have a value greater than 400. There is a lot of uncertainty labelling a new data point with an FL1H value of around 400 because the distributions merge significantly around 400. Therefore additional features will be need to classify these points.
# 
# 
# 
# 
# 
# - __Performance Metrics__
# In this analysis external evaluation is carried out whereby the labels given to the clusters are compared to the actual labels.The clustering models are evaluated using the Adjusted Rand Index. The Rand Index measures the proportion of correct decisions made by the algorithm and the Adjusted Rand Index is the corrected for chance version of the Rand Index. It needs to be corrected because even a random assignmentcan lead to a large Rand Index value.
# 
# $$ \text{Rand Index}=\frac{TP+TN}{TP+TN+FP+FN}$$
# 
# where 
# - $TP=\text{True Positives}$ 
# - $TN=\text{True Negatives}$
# - $FP=\text{False Positives}$
# - $FN=\text{False Negatives}$
# 
# $$\text{Adjusted Rand}=\frac{\text{Rand Index}-\text{Expected Rand Index}}{\max{\text{Rand Index}}-\text{Expected Rand Index}}$$
# 

# <a id="km"></a>
# -  __K Means Clustering__
# 
# K means clustering splits our data into k disjoint partitions according to a specific algorithm. The clustering algorithm seeks to split the data into k clusters so as to minimize the within cluster variance. In this case the clustering is done in 7 dimensional space and so is hard to visualise.The data usually needs to be scaled but in this case the variables are of a similar scale so standardisation is not needed. The training set data was delabelled and then k means clustering was performed on it. The output of this clustering was two labelled groups, one of which corresponded to Gate 0 and the other to Gate 1. This correspndence was identified and then points which were correctly classified by the k-means clustering algorithm were plotted in blue and orange for Gates 0 and 1 respectively. Points that were misclassified were labelled as green. External evaluation of the k means clustering was applied where the clusters were compared to the known class labels. 
# 
# The K means algorithm works by initally setting k random means $m^1_1,m^1_2,m^1_3,...,m^1_k$ in the 7D space of variables.
# 
# __Assignment Step__<br>
# Each observation $x_i$ is assigned to the mean $m_j$ which is closest to the observation in the space according a certain distance metric. In this case the Euclidean metric is used.This step generates k sets $S_i$ that contain all the elements that are closest to the mean $m_i^t$.
# $$d(x_i,x_j)=\sum_{n=1}^{7}(x_{i(n)}-x_{j(n)})^2$$
# 
# 
# __Update Step__<br>
# The means of the sets are then calculated and set as the means for the next assignment step.
# $$m_i^{t+1}=\frac{1}{|{S_i^t}|}\sum_{x_j\in{S_j^{t+1}}}x_j$$
# 
# The algorithm is continued until converge although it is not guaranteed top converge.
# 
# 

# In[ ]:


from sklearn.cluster import KMeans
Kmean = KMeans(n_clusters=2)
Kmean.fit(train_no_labels)
kmlabels=pd.DataFrame(Kmean.labels_)
tkl=train_set.copy()
kmlabels = kmlabels.set_index(train_set.index)
tkl['km']=kmlabels
# Running k means on separate occasions may yield different values for the labels, in this case 0 or 1
# The following is a probably bad way of setting the output of the k means labelling to be the one that I want so the graph labels are correct


def g(row):
    if (row['km'] == 0):
        val = 1
    elif (row['km']==1):
        val = 0
   
    return val

if((tkl['km'].iloc[0]!=0) and (tkl['km'].iloc[1]!=0)):
    tkl['km']=tkl.apply(g,axis=1)

def f(row):
    if (row['Gate'] == row['km'] and row['Gate']==0):
        val = 'Gate 0'
    elif (row['Gate'] == row['km'] and row['Gate']==1):
        val = 'Gate 1'
    elif row['Gate'] != row['km']:
        val = 'Misclassified'
    
    return val

tkl['colorlabel'] = tkl.apply(f, axis=1)

tkl.head()
print('The Scatter plot of the K Means clustering is shown below\n The green points correspond to points that were assigned to the wrong class')


# In[ ]:


ax=sb.pairplot(tkl,hue='colorlabel',plot_kws={'alpha': 0.3},vars=['FSCH', 'SSCH', 'FL1H', 'FL2H', 'FL3H', 'FL1A', 'FL1W','Gate'])
ax.fig.set_size_inches(20, 20);


# In[ ]:


ax=sb.pairplot(data=tkl,hue='colorlabel',vars=['FL1H'])
ax.fig.set_size_inches(12, 8);


# In[ ]:


from sklearn.metrics import adjusted_rand_score
adjrand=adjusted_rand_score(tkl['Gate'],tkl['km'])
rand=(tkl['colorlabel'].value_counts()[0]+tkl['colorlabel'].value_counts()[1])/(tkl['colorlabel'].value_counts().sum())
print('The Rand Index is ',round(rand,4))
print('The Adjusted Rand Index is ',round(adjrand,4))


# The results of the k means clustering above show:
# 
# - The subset of datapoints where $ 0 \leq \text{FL1H} \leq  300$ are similar to Gate 0
# - The subset of datapoints where $ 600 \leq \text{FL1H}$ are similar to Gate 1
# - There are many other subsets which seem to be well separated linearly in the 2D scatter plots such as the FL1H/FL2H scatter plot.
# 
# *If the data were plotted in the full 7 dimensions instead of 2-D scatter plots, it would probably reveal much greater separation between the clusters than is visible in the 2-D plots*
# 

# In[ ]:



from pandas.plotting import radviz
fig = plt.figure( )
fig.set_size_inches(12,10)

tr=tkl.drop(['Gate','colorlabel'],axis=1)
tr.head()
rad_viz = pd.plotting.radviz(tr, 'km',color=['blue','orange'],alpha=0.5)


# <a id="hc"></a>
# - __Hierarchical Clustering__
# 
# Hierarchical clustering creates a tree-like structure to create groups of observations which are similar.The aim of hierarchical clustering is to separate the data into clusters that have small variance within clusters and a large distance betwen clusters. Hierarchical clustering works by assigning each data point $x_i$ id assigned to a group on its own $S_i$ . The distance between groups is measured between the closest points is measured  using the Euclidean metric and the distance between groups is measured using either Single,Average,Complete or Ward linkage. The Single Average and Complete methods find the minimum,average and maximum distance respectively between points in each group. The Ward method determines that proximity between two clusters $S_i,S_j$ is the magnitude by which the summed square $\sum_S$ in their joint cluster $S_{12}$ will be greater than the combined summed square in these two clusters.
# $$ \sum_S=\sum_{x_j\in{S}}(x_j-\bar{x})^2$$
# 
# 
# The closest groups according to the linkage criterion are then joined and combined to form a single new group. This process is repeated until there is only one group remaining.This method is sensitive to the scale of the data but there is no need to scale the data in this case.
# 

# In[ ]:



from sklearn.cluster import AgglomerativeClustering
s=AgglomerativeClustering(n_clusters=2,linkage='single')
s.fit(train_no_labels)
rs=adjusted_rand_score(tkl['Gate'],s.labels_)
print('Adjusted Rand Index for Hierarchical Clustering with single linkage is ',round(rs,4))

a=AgglomerativeClustering(n_clusters=2,linkage='average')
a.fit(train_no_labels)
ra=adjusted_rand_score(tkl['Gate'],a.labels_)
print('Adjusted Rand Index for Hierarchical Clustering with average linkage is ',round(ra,4))

c=AgglomerativeClustering(n_clusters=2,linkage='complete')
c.fit(train_no_labels)
rc=adjusted_rand_score(tkl['Gate'],c.labels_)
print('Adjusted Rand Index for Hierarchical Clustering with complete linkage is ',round(rc,4))

w=AgglomerativeClustering(n_clusters=2,linkage='ward')
w.fit(train_no_labels)
rw=adjusted_rand_score(tkl['Gate'],w.labels_)
print('Adjusted Rand Index for Hierarchical Clustering with ward linkage is ',round(rw,4))


# In[ ]:


label=train_set.copy().pop('Gate')
lut = dict(zip(label.unique(), ['blue','orange']))
row_colors = label.map(lut)

sb.set(rc={'figure.figsize':(12,8)})
g = sb.clustermap(train_no_labels, col_cluster=False,method='ward',row_colors=row_colors)
plt.title('Hierarchical Clustering with ward linkage');


# Only the Cluster plot for the ward linkage method is shown as it is the best method according to the Adjusted Rand Index. The clusters are displayed on the left in a dendrogram. It's clear that there is a few data points mislabelled. Looking at the data points that are in the blue cluster but should be in the orange cluster it is clear why. The FL3H values are outliers within the cluster. The orange cluster tends to have higher FL3H values and this is why they are misclassified. These high readings could be down to an error in the detection equipment or random chance. Recalibration of the measurement equipment or increasing the sample size should resolve these issues if they are the cause.
# 
# - This plot again shows that data points with a high FL1H value tend to belong to Gate 1.
# - It also shows that data points with a low FL1A value are more likely to belong to Gate 0

# <a id="sup"></a>
# ## 5. Supervised Classification Methods
# ---
# 
# Supervised Learning is a subset of machine learning where labelled training data is used to infer a model which is used to classify new data points. The goal is to be able to provide accurate predictions of unseen data points therefore the must generalize from the structure of the training data to produce reasonable outputs.
# 
# K-Fold Cross Validation is where the training set is split randomly split K times(into K folds) and at each iteration a subset of it is used for training a learning model and the other set is used for evaluation of the model. It helps to eliminate overfitting of a model where the model poor resultson unseen data but gives good results on the training data.The following models will be evaluated using the Accuracy scoring metric given below. In the models below, stratified K fold validation is used to ensure that each fold is representative of the underlying data.
# 
# - __Performance Metric__
# The following performance metric is used to evaluate the effectiveness of the models.
# 
# $$\text{Accuracy}=\frac{\text{Number of Correct Decisons Made}}{\text{Total Decisions Made}}$$
# 
# 

# <a id="knn"></a>
# - __K Nearest Neighbors__
# 
# The K Nearest Neighbors model is a simple model where a data point $x_i$ is assigned to a class $C_j$ according to the following algorithm.
# 
# 1.  The K nearest points are calculated by evaluating the distance betwenn $x_i$ and it's neighbouring points.
# 2. The point $x_i$ is assigned to the class $C_j$ which most frequently occurs among the K nearest points
# 
# *The Euclidean metric is used again in this case*

# In[ ]:


from sklearn.neighbors import KNeighborsClassifier
from sklearn.model_selection import GridSearchCV
param_grid={'n_neighbors':[1,2,3,4,5,6,7,8,9,10]}
knn=KNeighborsClassifier()
grid_search=GridSearchCV(knn,param_grid,cv=5,scoring='accuracy',return_train_score=True)
grid_search.fit(train_no_labels,train_labels);


# In[ ]:


c=grid_search.cv_results_
print ('10 K Nearest Neighbors classifiers were trained on 5 stratified subsets of the data and evaluted on the part that was not used for training\n')
print('Evaluating K Nearest Neighbor Classifier predictions...\n')
print ('The mean accuracy score for the 10 classifiers on the 5 folds are shown below\n')

for mean_score,params in zip(c['mean_test_score'],c['params']):
    print (round(mean_score,5),params)
print ('The optimal model has mean score',round(c['mean_test_score'][4],4))


# The optimum K Nearest Neighbors Classifer on the training set is when $K=5$.

# <a id="lr"></a>
# - __Logictic Regression__
# 
# A Logistic Regression model is a statistical model used to estimate the probability of a data point belonging to a certain class. The Logistic Regression model attempts to capture the relationship between the input variables and class in the training phase. This knowledge is then used to predict the class of new data points. Logistic Regression is similar to linear regression but the output is limited to the the range $(0,1)$. The output correspnds to the probability of a data point belonging to a particular class.
# 
# *Stochastic Gradient Descent is used to train this model due to it's speed of convergence*

# In[ ]:


from sklearn.model_selection import StratifiedKFold
from sklearn.model_selection import cross_validate
from sklearn.linear_model import SGDClassifier
log_clf=SGDClassifier(loss='log',random_state=42)
cv=cross_validate(log_clf,train_no_labels,train_labels,scoring='accuracy',cv=StratifiedKFold(5))
s=0

print('Evaluating Logistic Regression Model predictions...\n')
for i,x in enumerate(cv['test_score']):
    s+=x
    print('The accuracy of the logistic classifier on fold',i+1,'is',round(x,5))

print('\nThe mean of the accuracy of the model on the 5 folds is',round(s/5,4))

    


# <a id="dt"></a>
# - __Decision Tree Classifier__
# 
# A decison tree classifier is a tree structure where each internal  non-leaf node represents an input variable. There are edges connecting the node to child nodes. When a new data point is inputted into the trained classier and reaches a new node, a decison is made as to which child node to go to. This is repeated at each step until the point reaches a leaf node and is classified. The decisions to be made at each node are determined during the training prcoess.These rules are chosen mathematically so that variables' values are selected to get the best split to differentiate observations based on the dependent variable. This ensures that the classification should have a small error.
# 
# 

# In[ ]:


from sklearn.tree import DecisionTreeClassifier
param_grid={'max_depth':[2,4,6,8,10]}
tree=DecisionTreeClassifier()
grid_search=GridSearchCV(tree,param_grid,cv=5,scoring='accuracy',return_train_score=True)
grid_search.fit(train_no_labels,train_labels);


# In[ ]:


c=grid_search.cv_results_
print ('5 Decision Tree Classifiers were trained on 5 stratified subsets of the data and evaluted on the part that was not used for training\n')
print('Evaluating Decison Tree Classifier predictions...\n')
print ('The mean accuracy score for the 5 classifiers on the 5 folds are shown below\n')

for mean_score,params in zip(c['mean_test_score'],c['params']):
    print (round(mean_score,5),params)
print('\nThe optimal depth of the decision tree with the settings chosen is',grid_search.best_params_['max_depth'])


# <a id="mlp"></a>
# - __Multi Layer Perceptron__
# 
# A multi layer perceptron is a type of Artificial Neural Network that consists of an input layer, an output layer and one or more hidden layers with each layer consisting of artificial neurons. Artificial Neural Networks are biologically inspired learning methods that mimic the human brain. An MLP with 12 neurons in the hidden layer is trained below.
# 
# 
# 

# In[ ]:


import tensorflow as ts
from tensorflow import keras
from keras.models import Sequential
from keras.layers import Activation, Dense


model = Sequential()
model.add(Dense(12, input_dim=7, activation='relu'))

model.add(Dense(1, activation='sigmoid'))
model.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])

model.fit(train_no_labels, train_labels, epochs=100, batch_size=10,verbose=0)
print('Training Multi Layer Perceptron...')
model.evaluate(train_no_labels,train_labels)
print('Evaluating model on test set')
y_pred=model.predict_classes(test_no_labels)
mlp_score=accuracy_score(test_labels,y_pred)

print('The Accuracy of the Multi Layer Perceptron on the test set is',round(mlp_score,4))


# <a id="em"></a>
# ## 6. Ensemble Methods
# 
# The basic idea of Ensemble methods used in classification is that the aggregate of the model's answers are likely to be better than single model's answer. For example if you had 1000 indepedent classifiers which were each correct only 51% of the time and if you choose to classify a new data point as the class which it was frequently classified as then this ensemble classifier would be right about 75% of the time.However this is only true if the classifiers made uncorrelated errors which is not true because they were trained on the same data. Ensemble methods work when the component classifiers are as independent as possible. This can be done by trainiing them on different subsets of data or using completely different algorithms.
# <a id="bag"></a>
# - __Bagging Methods__
# 
# The bagging method uses the former way of producing a varied set of classifiers by training them on different subsets of data.These classifiers then vote on which class they think a new data point is. This data point is assigned to the class with the majority of votes.The Random Forest Classifier is an example of an ensemble bagging method. A Random Forest Classifier is a bagging method where many Decision Tree Classifiers(with a slight variation in how they are trained to speed up the algorithm) are trained on different subsets of data.The Trees then vote on the classes and the mode is chosen. The depth of the Decision Trees used below is set as the optimal depth found above.
# 
# 

# In[ ]:


from sklearn.ensemble import RandomForestClassifier
forest_clf=RandomForestClassifier(n_estimators=100,max_depth=4);
forest_clf.fit(train_no_labels,train_labels);
print('Evaluating Random Forest Classifier predictions on the training set...\n')
print('The accuracy of the Random Forest Classifier with 100 trees on the training set is',round(forest_clf.score(train_no_labels,train_labels),4))


# This result is greater than any of the indidual Decision Trees shown above.

# <a id="vote"></a>
# - __Voting Classifiers__
# 
# A voting classifier consists of many individual classifiers.The voting classifiers aggregates the votes of each of these classifiers and predicts the class that gets the most votes. This particular type of voting classifer is a hard voting classifier since it doesnt take into account the class probabilities.In the Voting Classifier below, the component classifiers are a K Nearest Neighbours classifier with $K=5$, a Logistic Regression model and a Random Forest Classifier. 

# In[ ]:





from sklearn.ensemble import VotingClassifier
voting_clf=VotingClassifier(estimators=[('for',forest_clf),('log',SGDClassifier(loss='log',random_state=42)),('knn',KNeighborsClassifier(n_neighbors=5))],voting='hard')
voting_clf.fit(train_no_labels,train_labels);
print('Evaluating Voting Classifier predictions on the training set...\n')
print('The accuracy of the Voting Classifier on the training set is',round(voting_clf.score(train_no_labels,train_labels),4))


# The Voting Classifier is actually worse in this case than the Random Forest Classifier in this case but not by a significant amount.

# <a id="res"></a>
# ## 7. Results 
# 
# The various classifiers are now used on the test set to predict new values. This will give a true measure of the predictive power of the models on data that it has not seen before.

# In[ ]:






y_test = np.asarray(test_labels)



knn=KNeighborsClassifier(n_neighbors=5)
knn.fit(train_no_labels,train_labels)


print('Evaluating models on test set...\n')


    

knn.fit(train_no_labels,train_labels)
kpred_labels=knn.predict(test_no_labels)
kmis= np.where(y_test != knn.predict(test_no_labels))


print('Accuracy score for KNeighbors Classifier on test set is',round(100*accuracy_score(test_labels,kpred_labels),4),'%')

log_clf.fit(train_no_labels,train_labels)
lpred_labels=log_clf.predict(test_no_labels)
lmis= np.where(y_test != log_clf.predict(test_no_labels))

print('Accuracy score for Logistic Regression model on test set is',round(100*accuracy_score(test_labels,lpred_labels),4),'%')



print('Accuracy score for Multi Layer Perceptron on test set is',round(100*mlp_score,4),'%')



voting_clf.fit(train_no_labels,train_labels)
vpred_labels=voting_clf.predict(test_no_labels)
vmis= np.where(y_test != voting_clf.predict(test_no_labels))

print('Accuracy score for Voting Classifier on test set is',round(100*accuracy_score(test_labels,vpred_labels),4),'%')

forest_clf.fit(train_no_labels,train_labels)
fpred_labels=forest_clf.predict(test_no_labels)
fmis= np.where(y_test != forest_clf.predict(test_no_labels))


print('Accuracy score for Random Forest Classifier on test set is',round(accuracy_score(test_labels,fpred_labels)*100,4),'%')



# This shows that all of the models achieved above 95% accuracy in classifying the cell as the same class that the reseacher who made this dataset did. It does not tell us the actual cell types because it is unknown whether the researcher's gating protocol was effective or if the flow cytometer was functioning correctly.
# <a id="misclf"></a>
# - __Misclassified points__
# 
# The points that were misclassified by some of the models were analysed below. The top 3 most accurate models were chosen and the points that were misclassified by them were analysed. The FL1H parameter is very important for classifying the cells as is shown in the correlation matrix. Thus if a cell has a FL1H parameter value that is an outlier for it's group then presumably it may be misclassified. This presumption is verified below.
# 
# 

# In[ ]:


misclassified=set()
misclassified.update(vmis[0])
misclassified.update(kmis[0])
misclassified.update(fmis[0])
misclassified   #This set contains indices of misclassified elements in y_test
                #Must retrieve indices from test_labels
    
misclassified_t_indices=set()
for val in misclassified:
    misclassified_t_indices.add(test_labels.index[val])
    

print('Indices of misclassified points by the models are',misclassified_t_indices,'\n')     #These are the indices where the cell is misclassified by the f,k,v models in test_set


def get_sigma_fl1h(idx):
    gate=rit1[rit1.index==idx]['Gate'].values[0]
    classified_gate=1-gate
    
    mean=rit1[rit1['Gate']==gate]['FL1H'].mean()
    classified_mean=rit1[rit1['Gate']==classified_gate]['FL1H'].mean()
    
    std=rit1[rit1['Gate']==gate]['FL1H'].std()
    cls_std=rit1[rit1['Gate']==classified_gate]['FL1H'].std()
    val=rit1.loc[idx]['FL1H']
    return (val-mean)/std,(val-classified_mean)/cls_std

for i,val in enumerate(misclassified_t_indices):
    print ('Misclassified data point',i+1,'is',get_sigma_fl1h(val)[0],'standard deviations away from the mean of the FL1H parameter of it\'s correct gate\n')
    print ('Misclassified data point',i+1,'is',get_sigma_fl1h(val)[1],'standard deviations away from the mean of the FL1H parameter of it\'s classified gate\n')


# This shows that misclassified points tend to have FL1H values that are not typical for points of it's correct gate. It also shows that these points tend to be a lesser number of standard deviations away from the mean of their classified class than their actual class.

# <a id="conc"></a>
# ## 8. Conclusion
# Flow Cytometry data from an experiment using the drug Rituximab was analysed to determine which gate a particular data point/cell belonged to.These gates were assigned by the researcher according to an unknown gating protocol. Both unsupervised and supervised methods were employed to investigate the structure of the data and to see if each gate had some defining characteristics. It was found that the FL1H parameter was important in determing which gate a particular cell belonged to. The supervised models employed all achieved over 90% accuracy on the test set.
