#!/usr/bin/env python
# coding: utf-8

# In[ ]:


# This Python 3 environment comes with many helpful analytics libraries installed
# It is defined by the kaggle/python docker image: https://github.com/kaggle/docker-python
# For example, here's several helpful packages to load in 

import numpy as np # linear algebra
import pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)

# Input data files are available in the "../input/" directory.
# For example, running this (by clicking run or pressing Shift+Enter) will list the files in the input directory

import os
print(os.listdir("../input"))

# Any results you write to the current directory are saved as output.


# In[ ]:


train=pd.read_csv('../input/train.csv',nrows=1000)


# In[ ]:


train.head(10)


# In[ ]:


train.HasDetections.value_counts()


# In[ ]:


no_detections=train.loc[train['HasDetections']==0]


# In[ ]:


no_detections


# In[ ]:


train['HasTpm'].value_counts()


# In[ ]:


train.OsBuild.value_counts().plot.bar()
train.Census_OSEdition.value_counts()


# **Feature Engineering :
# Converting the feature IsProtected into bool **

# In[ ]:


def convert_bool(feature):
    train[feature]=train[feature].astype('bool')
    train[feature]=train[feature].astype('int')
    return train[feature]


# In[ ]:


train.IsProtected.dtype


# In[ ]:


convert_bool('Firewall')
convert_bool('AVProductsEnabled')
convert_bool('IsProtected')
convert_bool('UacLuaenable')


# **Converting the below categories into numerical labels using LabelEncoder**

# In[ ]:


train['Census_ChassisTypeName'].value_counts()


# In[ ]:


train.Census_ChassisTypeName.value_counts()
from sklearn.preprocessing import LabelEncoder

l=LabelEncoder()
OS_Arch=LabelEncoder()
encoded_labels_ChasisType=l.fit_transform(train['Census_ChassisTypeName'])
train['Census_ChassisTypeName']=encoded_labels_ChasisType

Arch=OS_Arch.fit_transform(train['Census_OSArchitecture'])
train['Census_OSArchitecture']=Arch


# **Checking the features after encoding using LabelEncoder **

# In[ ]:


train['Census_ChassisTypeName'].value_counts()

for i,v in enumerate(l.classes_):
    print(i,v)


# In[ ]:


train['Census_PowerPlatformRoleName'].value_counts()
train['Census_FlightRing'].value_counts()


# In[ ]:


new_feature=[]

new_feature=list(zip(train['Census_PowerPlatformRoleName'],train['HasDetections']))


# In[ ]:


train['Detection_Platform']=new_feature


# In[ ]:


train.Detection_Platform.value_counts().plot.bar()


# In[ ]:


train.dtypes


# In[ ]:




for i,v in enumerate(OS_Arch.classes_):
    print(i,v)


# In[ ]:


train['Census_TotalPhysicalRAM'].value_counts()


# In[ ]:


train['Census_ChassisTypeName']


# In[ ]:


train.columns[0:50]


# In[ ]:



for i in train.columns[0:85]:
    print("###################")
    print(i)
    print(train[i].value_counts())




# **Analyzing the HasDetections  based on the OSBuild type**

# In[ ]:


train['OSBuild_Detections']=list(zip(train['OsBuildLab'],train['HasDetections']))


# In[ ]:


plt.figure(figsize=(20,11))
train['OSBuild_Detections'].value_counts().plot.bar()


# In[ ]:


len(set(train['OsBuildLab']))


# In[ ]:


len(set(train['OSBuild_Detections']))


# In[ ]:


train['OSBuild_Detections'].value_counts()


# In[ ]:


train['OsSuite'].value_counts()


# In[ ]:




