#!/usr/bin/env python
# coding: utf-8

# # Install kaggle-environments

# In[ ]:


# 1. Enable Internet in the Kernel (Settings side pane)

# 2. Curl cache may need purged if v0.1.6 cannot be found (uncomment if needed). 
# !curl -X PURGE https://pypi.org/simple/kaggle-environments

# Halite environment was defined in v0.2.1
get_ipython().system("pip install 'kaggle-environments>=0.2.1'")


# # Create Halite Environment

# In[ ]:


from kaggle_environments import evaluate, make

env = make("halite", debug=True)
env.render()


# # Create a Submission (agent)
# 
# To submit to the competition, a python file must be created where the last function is the "act" (the function which given an observation generates an action).  Logic above the "act" function is allowed including helpers.  Any python that executes immediately will be run during the initialize phase and not included in the "act timeout".
# 
# When your agent is being evaluated against others, it will not have access to the Kaggle docker image. Only the following can be imported: Python Standard Library Modules, gym, numpy, scipy, pytorch (1.3.1, cpu only), and more may be added later.

# In[ ]:


get_ipython().run_cell_magic('writefile', 'submission.py', '# for Debug/Train previous line should be commented out, uncomment to write submission.py\n\nimport numpy as np\n\ndef reset_game_map(obs):\n    """ redefine game_map as two dimensional array of objects and set amounts of halite in each cell """\n    global game_map\n    game_map = []\n    for x in range(conf.size):\n        game_map.append([])\n        for y in range(conf.size):\n            game_map[x].append({\n                # value will be ID of owner\n                "shipyard": None,\n                # value will be ID of owner\n                "ship": None,\n                # amount of halite\n                "halite": obs.halite[conf.size * y + x]\n            })\n\ndef get_my_units_coords_and_update_game_map(obs):\n    """ get lists of coords of my units and update locations of ships and shipyards on the map """\n    # arrays of (x, y) coords\n    my_shipyards_coords = []\n    my_ships_coords = []\n    \n    for player in range(len(obs.players)):\n        shipyards = list(obs.players[player][1].values())\n        for shipyard in shipyards:\n            x = shipyard % conf.size\n            y = shipyard // conf.size\n            # place shipyard on the map\n            game_map[x][y]["shipyard"] = player\n            if player == obs.player:\n                my_shipyards_coords.append((x, y))\n        \n        ships = list(obs.players[player][2].values())\n        for ship in ships:\n            x = ship[0] % conf.size\n            y = ship[0] // conf.size\n            # place ship on the map\n            game_map[x][y]["ship"] = player\n            if player == obs.player:\n                my_ships_coords.append((x, y))\n    return my_shipyards_coords, my_ships_coords\n\n\ndef findNearestYard(my_shipyards_coords, x, y):\n    """ find nearest shipyard to deposit there"""\n    min_dist = conf.size * 2\n    closest_yard = 0\n    for yard_idx, yard in enumerate(my_shipyards_coords):\n        dist = np.min( (  ((x - my_shipyards_coords[yard_idx][0]) % conf.size), \n                                (21 - ((x - my_shipyards_coords[yard_idx][0]) % conf.size))  ) ) \\\n          + np.min( (  ((y - my_shipyards_coords[yard_idx][1]) % conf.size), \n                     (21 - ((y - my_shipyards_coords[yard_idx][1]) % conf.size))  ) )\n        if dist < min_dist:\n            min_dist = dist;\n            closest_yard = yard_idx\n    return closest_yard, min_dist\n            \n\n\ndef get_x(x):\n    """ get x, considering donut type of the map """\n    return (x % conf.size)\n\ndef get_y(y):\n    """ get y, considering donut type of the map """\n    return (y % conf.size)\n\ndef clear(x, y, player):\n    """ check if cell is safe to move in """\n    # if there is no shipyard, or there is player\'s shipyard\n    # and there is no ship\n    if ((game_map[x][y]["shipyard"] == player or game_map[x][y]["shipyard"] == None) and\n            game_map[x][y]["ship"] == None):\n        return True\n    return False\n\n\ndef moveTo(x_initial, y_initial, x_target, y_target, ship_id, player, actions):\n    """ move toward target as quickly as possible without collision (or later, bad collision)"""\n    if (x_target - x_initial) % conf.size <=  ( 1 + conf.size) // 2 :\n        # move down\n        x_dir = 1;\n        x_dist = (x_target - x_initial) % conf.size\n    else:\n        # move up\n        x_dir = -1;\n        x_dist = (x_initial - x_target) % conf.size\n    \n    if (y_target - y_initial) % conf.size <=  ( 1 + conf.size) // 2 :\n        # move down\n        y_dir = 1;\n        y_dist = (y_target - y_initial) % conf.size\n    else:\n        # move up\n        y_dir = -1;\n        y_dist = (y_initial - y_target) % conf.size\n    \n    action = None\n    if x_dist > y_dist:\n        # move X first if can;\n        if clear( ( x_initial + x_dir) % conf.size, y_initial, player):\n            action = (\'WEST\' if x_dir <0 else \'EAST\')\n        elif clear( x_initial, ( y_initial + y_dir) % conf.size, player) :\n            action = (\'NORTH\' if y_dir < 0 else \'SOUTH\')\n    else:\n        # move Y first if can\n        if clear( x_initial, ( y_initial + y_dir) % conf.size, player) :\n            action = (\'NORTH\' if y_dir < 0 else \'SOUTH\')\n        elif clear( ( x_initial + x_dir) % conf.size, y_initial, player):\n            action = (\'WEST\' if x_dir <0 else \'EAST\')\n            \n    if action is not None:\n        game_map[x_initial][y_initial]["ship"] = None\n        actions[ship_id] = action\n        \n    if action == \'NORTH\':\n        game_map[x_initial][(y_initial - 1) % conf.size]["ship"] = player\n    elif action == \'SOUTH\':\n        game_map[x_initial][(y_initial + 1) % conf.size]["ship"] = player\n    elif action == \'EAST\':\n        game_map[(x_initial - 1) % conf.size][y_initial]["ship"] = player\n    elif action == \'WEST\':\n        game_map[(x_initial + 1) % conf.size][y_initial]["ship"] = player\n    \n    return actions\n    \n\ndef move_ship(x_initial, y_initial, ship_id, actions, player, ships_amount):\n    """ \n        ship will move in expanding circles clockwise or counterclockwise\n        until reaching maximum radius, then radius will be minimal again\n    """\n    directions = ships_data[ship_id]["directions"]\n    # set index of direction\n    i = ships_data[ship_id]["directions_index"]\n    for j in range(len(directions)):\n        x = directions[i]["x"](x_initial)\n        y = directions[i]["y"](y_initial)\n        \n        # if cell is ok to move in\n        if (((clear(x, y, player) or (ships_amount > 10 and game_map[x][y]["ship"] == None))\n                 and not enemy_ship_near(x, y, player)) or\n                (ships_amount > 30 and game_map[x][y]["ship"] != player)):\n            ships_data[ship_id]["moves_done"] += 1\n            \n            # apply changes to game_map, to avoid collisions of player\'s ships next turn\n            game_map[x_initial][y_initial]["ship"] = None\n            game_map[x][y]["ship"] = player\n            \n            # if it was last move in this direction, change direction\n            if ships_data[ship_id]["moves_done"] >= ships_data[ship_id]["ship_max_moves"]:\n                ships_data[ship_id]["moves_done"] = 0\n                ships_data[ship_id]["directions_index"] += 1\n                \n                # if it is last direction in a list\n                if ships_data[ship_id]["directions_index"] >= len(directions):\n                    ships_data[ship_id]["directions_index"] = 0\n                    ships_data[ship_id]["ship_max_moves"] += 1\n                    \n                    # if ship_max_moves reached maximum radius expansion\n                    if ships_data[ship_id]["ship_max_moves"] >= max_moves_amount:\n                        ships_data[ship_id]["ship_max_moves"] = 1\n            actions[ship_id] = directions[i]["direction"]\n            break\n        else:\n            # loop through directions\n            i += 1\n            if i >= len(directions):\n                i = 0\n    return actions\n\n\ndef get_directions(i0, i1, i2, i3):\n    """ get list of directions in a certain sequence """\n    return [directions[i0], directions[i1], directions[i2], directions[i3]]\n\ndef enemy_ship_near(x, y, player):\n    """ check if enemy ship is in one move away from game_map[x][y] """\n    if (\n            (game_map[x][get_y(y - 1)]["ship"] != player and game_map[x][get_y(y - 1)]["ship"] != None) or\n            (game_map[x][get_y(y + 1)]["ship"] != player and game_map[x][get_y(y + 1)]["ship"] != None) or\n            (game_map[get_x(x + 1)][y]["ship"] != player and game_map[get_x(x + 1)][y]["ship"] != None) or\n            (game_map[get_x(x - 1)][y]["ship"] != player and game_map[get_x(x - 1)][y]["ship"] != None)\n        ): return True\n    return False\n\ndef define_some_globals(config):\n    """ define some of the global variables """\n    global conf\n    global turns_to_next_wave_of_ships\n    global convert_plus_spawn_cost\n    global max_moves_amount\n    global globals_not_defined\n    conf = config\n    turns_to_next_wave_of_ships = conf.size // 2               # tunable and cappable late in game obviously\n    convert_plus_spawn_cost = conf.convertCost + conf.spawnCost\n    max_moves_amount = conf.size // 2                             # tunable\n    globals_not_defined = False\n\n\n############################################################################\nconf = None\ngame_map = [] \nships_data = {}  \nturns_to_next_wave_of_ships = None   \ntactics_index = 0   \nconvert_plus_spawn_cost = None  \nship_spawn_turn = 0  \nmax_moves_amount = None  \nglobals_not_defined = True \n\nlow_amount_of_halite = 150         \n\nMIN_FINAL_DROPOFF = 150   \nPCTILE_DROPOFF = 80   \nRETURN_HOME = 350  \nMUST_DROPOFF = 2000\n\nSHIP_TO_BASE_MULT = 2   \n\n\n\n# list of directions\ndirections = [\n    {\n        "direction": "NORTH",\n        "x": lambda z: z,\n        "y": lambda z: get_y(z - 1)\n    },\n    {\n        "direction": "EAST",\n        "x": lambda z: get_x(z + 1),\n        "y": lambda z: z\n    },\n    {\n        "direction": "SOUTH",\n        "x": lambda z: z,\n        "y": lambda z: get_y(z + 1)\n    },\n    {\n        "direction": "WEST",\n        "x": lambda z: get_x(z - 1),\n        "y": lambda z: z\n    }\n]\n\n# list of tactics\ntactics = [\n    # N -> E -> S -> W\n    {"directions": get_directions(0, 1, 2, 3)},\n    # S -> E -> N -> W\n    {"directions": get_directions(2, 1, 0, 3)},\n    # N -> W -> S -> E\n    {"directions": get_directions(0, 3, 2, 1)},\n    # S -> W -> N -> E\n    {"directions": get_directions(2, 3, 0, 1)},\n    # E -> N -> W -> S\n    {"directions": get_directions(1, 0, 3, 2)},\n    # W -> S -> E -> N\n    {"directions": get_directions(3, 2, 1, 0)},\n    # E -> S -> W -> N\n    {"directions": get_directions(1, 2, 3, 0)},\n    # W -> N -> E -> S\n    {"directions": get_directions(3, 0, 1, 2)},\n]\ntactics_amount = len(tactics)\n\n\ndef swarm_agent(obs, config):\n    global ship_spawn_turn\n    global tactics_index\n    if globals_not_defined:\n        define_some_globals(config)\n    actions = {}\n    my_halite = obs.players[obs.player][0]\n    \n    reset_game_map(obs)\n    my_shipyards_coords, my_ships_coords = get_my_units_coords_and_update_game_map(obs)\n\n    ships_keys = list(obs.players[obs.player][2].keys())\n    ships_values = list(obs.players[obs.player][2].values())\n    shipyards_keys = list(obs.players[obs.player][1].keys())\n\n#     return {ships_keys[0]: "CONVERT"}\n\n\n    \n    # if there is no shipyards\n    if len(shipyards_keys) == 0 and (my_halite >= conf.convertCost or ships_values[0][1] >= convert_plus_spawn_cost):\n        actions[ships_keys[0]] = "CONVERT"\n\n    else:\n        # if (there are no ships or only one shipyard)     and         enough halite to spawn at least one ship\n        #         then spawn a ship out of there\n        \n        if (len(ships_keys) == 0 or len(shipyards_keys) == 1) and my_halite >= conf.spawnCost:\n            ship_spawn_turn = obs.step + turns_to_next_wave_of_ships\n            for i in range(len(my_shipyards_coords)):\n                if my_halite >= conf.spawnCost:\n                    x = my_shipyards_coords[i][0]\n                    y = my_shipyards_coords[i][1]\n                    if clear(x, y, obs.player):\n                        my_halite -= conf.spawnCost\n                        actions[shipyards_keys[i]] = "SPAWN"\n                        game_map[x][y]["ship"] = obs.player\n                        \n        # if it is time to spawn another wave of ships and there is enough halite to spawn at least one ship\n        elif obs.step >= ship_spawn_turn and my_halite >= conf.spawnCost and obs.step < RETURN_HOME:\n            for i in range(len(my_shipyards_coords)):\n                if my_halite >= conf.spawnCost:\n                    x = my_shipyards_coords[i][0]\n                    y = my_shipyards_coords[i][1]\n                    if clear(x, y, obs.player):\n                        my_halite -= conf.spawnCost\n                        actions[shipyards_keys[i]] = "SPAWN"\n                        game_map[x][y]["ship"] = obs.player\n                else:\n                    ship_spawn_turn += turns_to_next_wave_of_ships\n                    break\n        \n        # actions of ships\n        for i in range(len(my_ships_coords)):\n            x = my_ships_coords[i][0]\n            y = my_ships_coords[i][1]\n            \n            # if this is a new ship\n            if ships_keys[i] not in ships_data:\n                ships_data[ships_keys[i]] = {\n                    "moves_done": 0, "ship_max_moves": 1,\n                    "directions": tactics[tactics_index]["directions"], "directions_index": 0 }\n                tactics_index = (tactics_index + 1) % tactics_amount\n                    \n            # if ship has enough halite to convert to shipyard and not at halite source\n            # or ship has two times convert_plus_spawn_cost amount of halite\n            #   then turn it into a shipyard\n            #    (add exception: if late game and have plenty of shipyards, or shipyards beyond necessary ratio, don\'t)\n            elif ((ships_values[i][1] >= convert_plus_spawn_cost and game_map[x][y]["halite"] == 0) or\n                    ships_values[i][1] >= (convert_plus_spawn_cost * SHIP_TO_BASE_MULT)):\n                actions[ships_keys[i]] = "CONVERT"\n                \n                game_map[x][y]["ship"] = None\n                \n            # if this cell has low amount of halite or enemy ship is near\n            elif game_map[x][y]["halite"] < low_amount_of_halite or enemy_ship_near(x, y, obs.player): \n                actions = move_ship(x, y, ships_keys[i], actions, obs.player, len(ships_keys))\n            \n            # IF TIME TO RETURN HOME AND DEPOSIT\n\n                      \n            if ( (obs.step > RETURN_HOME) and \n                  (  (ships_values[i][1] > MIN_FINAL_DROPOFF) or \n                           (ships_values[i][1] >  np.percentile( [s[1] for s in ships_values], PCTILE_DROPOFF) ) )\n               or    (ships_values[i][1] > MUST_DROPOFF  ) ):\n#                 print()\n                # locate nearest shipyard\n                if len(my_shipyards_coords) > 0:\n                    closest_yard, min_dist = findNearestYard(my_shipyards_coords, x, y)\n                    # move that way as long as don\'t collide with a ship\n                    actions = moveTo(x, y, *my_shipyards_coords[closest_yard], ships_keys[i], obs.player, actions)\n\n                    \n#     if obs.step % 50 == 0:\n#                 print(obs.step)\n    return actions')


# In[ ]:





# ### Old Agents to Test Against

# In[ ]:


get_ipython().run_cell_magic('writefile', 'a2.py', '# for Debug/Train previous line should be commented out, uncomment to write submission.py\n\nimport numpy as np\n\ndef reset_game_map(obs):\n    """ redefine game_map as two dimensional array of objects and set amounts of halite in each cell """\n    global game_map\n    game_map = []\n    for x in range(conf.size):\n        game_map.append([])\n        for y in range(conf.size):\n            game_map[x].append({\n                # value will be ID of owner\n                "shipyard": None,\n                # value will be ID of owner\n                "ship": None,\n                # amount of halite\n                "halite": obs.halite[conf.size * y + x]\n            })\n\ndef get_my_units_coords_and_update_game_map(obs):\n    """ get lists of coords of my units and update locations of ships and shipyards on the map """\n    # arrays of (x, y) coords\n    my_shipyards_coords = []\n    my_ships_coords = []\n    \n    for player in range(len(obs.players)):\n        shipyards = list(obs.players[player][1].values())\n        for shipyard in shipyards:\n            x = shipyard % conf.size\n            y = shipyard // conf.size\n            # place shipyard on the map\n            game_map[x][y]["shipyard"] = player\n            if player == obs.player:\n                my_shipyards_coords.append((x, y))\n        \n        ships = list(obs.players[player][2].values())\n        for ship in ships:\n            x = ship[0] % conf.size\n            y = ship[0] // conf.size\n            # place ship on the map\n            game_map[x][y]["ship"] = player\n            if player == obs.player:\n                my_ships_coords.append((x, y))\n    return my_shipyards_coords, my_ships_coords\n\n\ndef findNearestYard(my_shipyards_coords, x, y):\n    """ find nearest shipyard to deposit there"""\n    min_dist = conf.size * 2\n    closest_yard = 0\n    for yard_idx, yard in enumerate(my_shipyards_coords):\n        dist = np.min( (  ((x - my_shipyards_coords[yard_idx][0]) % conf.size), \n                                (21 - ((x - my_shipyards_coords[yard_idx][0]) % conf.size))  ) ) \\\n          + np.min( (  ((y - my_shipyards_coords[yard_idx][1]) % conf.size), \n                     (21 - ((y - my_shipyards_coords[yard_idx][1]) % conf.size))  ) )\n        if dist < min_dist:\n            min_dist = dist;\n            closest_yard = yard_idx\n    return closest_yard, min_dist\n            \n\n\ndef get_x(x):\n    """ get x, considering donut type of the map """\n    return (x % conf.size)\n\ndef get_y(y):\n    """ get y, considering donut type of the map """\n    return (y % conf.size)\n\ndef clear(x, y, player):\n    """ check if cell is safe to move in """\n    # if there is no shipyard, or there is player\'s shipyard\n    # and there is no ship\n    if ((game_map[x][y]["shipyard"] == player or game_map[x][y]["shipyard"] == None) and\n            game_map[x][y]["ship"] == None):\n        return True\n    return False\n\n\ndef moveTo(x_initial, y_initial, x_target, y_target, ship_id, player, actions):\n    """ move toward target as quickly as possible without collision (or later, bad collision)"""\n    if (x_target - x_initial) % conf.size <=  ( 1 + conf.size) // 2 :\n        # move down\n        x_dir = 1;\n        x_dist = (x_target - x_initial) % conf.size\n    else:\n        # move up\n        x_dir = -1;\n        x_dist = (x_initial - x_target) % conf.size\n    \n    if (y_target - y_initial) % conf.size <=  ( 1 + conf.size) // 2 :\n        # move down\n        y_dir = 1;\n        y_dist = (y_target - y_initial) % conf.size\n    else:\n        # move up\n        y_dir = -1;\n        y_dist = (y_initial - y_target) % conf.size\n    \n    action = None\n    if x_dist > y_dist:\n        # move X first if can;\n        if clear( ( x_initial + x_dir) % conf.size, y_initial, player):\n            action = (\'WEST\' if x_dir <0 else \'EAST\')\n        elif clear( x_initial, ( y_initial + y_dir) % conf.size, player) :\n            action = (\'NORTH\' if y_dir < 0 else \'SOUTH\')\n    else:\n        # move Y first if can\n        if clear( x_initial, ( y_initial + y_dir) % conf.size, player) :\n            action = (\'NORTH\' if y_dir < 0 else \'SOUTH\')\n        elif clear( ( x_initial + x_dir) % conf.size, y_initial, player):\n            action = (\'WEST\' if x_dir <0 else \'EAST\')\n            \n    if action is not None:\n        game_map[x_initial][y_initial]["ship"] = None\n        actions[ship_id] = action\n        \n    if action == \'NORTH\':\n        game_map[x_initial][(y_initial - 1) % conf.size]["ship"] = player\n    elif action == \'SOUTH\':\n        game_map[x_initial][(y_initial + 1) % conf.size]["ship"] = player\n    elif action == \'EAST\':\n        game_map[(x_initial - 1) % conf.size][y_initial]["ship"] = player\n    elif action == \'WEST\':\n        game_map[(x_initial + 1) % conf.size][y_initial]["ship"] = player\n    \n    return actions\n    \n\ndef move_ship(x_initial, y_initial, ship_id, actions, player, ships_amount):\n    """ \n        ship will move in expanding circles clockwise or counterclockwise\n        until reaching maximum radius, then radius will be minimal again\n    """\n    directions = ships_data[ship_id]["directions"]\n    # set index of direction\n    i = ships_data[ship_id]["directions_index"]\n    for j in range(len(directions)):\n        x = directions[i]["x"](x_initial)\n        y = directions[i]["y"](y_initial)\n        # if cell is ok to move in\n        if (((clear(x, y, player) or (ships_amount > 10 and game_map[x][y]["ship"] == None)) and not enemy_ship_near(x, y, player)) or\n                (ships_amount > 30 and game_map[x][y]["ship"] != player)):\n            ships_data[ship_id]["moves_done"] += 1\n            # apply changes to game_map, to avoid collisions of player\'s ships next turn\n            game_map[x_initial][y_initial]["ship"] = None\n            game_map[x][y]["ship"] = player\n            # if it was last move in this direction\n            if ships_data[ship_id]["moves_done"] >= ships_data[ship_id]["ship_max_moves"]:\n                ships_data[ship_id]["moves_done"] = 0\n                ships_data[ship_id]["directions_index"] += 1\n                # if it is last direction in a list\n                if ships_data[ship_id]["directions_index"] >= len(directions):\n                    ships_data[ship_id]["directions_index"] = 0\n                    ships_data[ship_id]["ship_max_moves"] += 1\n                    # if ship_max_moves reached maximum radius expansion\n                    if ships_data[ship_id]["ship_max_moves"] >= max_moves_amount:\n                        ships_data[ship_id]["ship_max_moves"] = 1\n            actions[ship_id] = directions[i]["direction"]\n            break\n        else:\n            # loop through directions\n            i += 1\n            if i >= len(directions):\n                i = 0\n    return actions\n\n\ndef get_directions(i0, i1, i2, i3):\n    """ get list of directions in a certain sequence """\n    return [directions[i0], directions[i1], directions[i2], directions[i3]]\n\ndef enemy_ship_near(x, y, player):\n    """ check if enemy ship is in one move away from game_map[x][y] """\n    if (\n            (game_map[x][get_y(y - 1)]["ship"] != player and game_map[x][get_y(y - 1)]["ship"] != None) or\n            (game_map[x][get_y(y + 1)]["ship"] != player and game_map[x][get_y(y + 1)]["ship"] != None) or\n            (game_map[get_x(x + 1)][y]["ship"] != player and game_map[get_x(x + 1)][y]["ship"] != None) or\n            (game_map[get_x(x - 1)][y]["ship"] != player and game_map[get_x(x - 1)][y]["ship"] != None)\n        ): return True\n    return False\n\ndef define_some_globals(config):\n    """ define some of the global variables """\n    global conf\n    global turns_to_next_wave_of_ships\n    global convert_plus_spawn_cost\n    global max_moves_amount\n    global globals_not_defined\n    conf = config\n    turns_to_next_wave_of_ships = conf.size // 2\n    convert_plus_spawn_cost = conf.convertCost + conf.spawnCost\n    max_moves_amount = conf.size // 2\n    globals_not_defined = False\n\n\n############################################################################\nconf = None\ngame_map = [] \nships_data = {}  \nturns_to_next_wave_of_ships = None   \ntactics_index = 0   \nlow_amount_of_halite = 200   \nconvert_plus_spawn_cost = None  \nship_spawn_turn = 0  \nmax_moves_amount = None  \nglobals_not_defined = True \n\n\nMIN_FINAL_DROPOFF = 150\nRETURN_HOME = 350\nMUST_DROPOFF = 1000\n\n\n# list of directions\ndirections = [\n    {\n        "direction": "NORTH",\n        "x": lambda z: z,\n        "y": lambda z: get_y(z - 1)\n    },\n    {\n        "direction": "EAST",\n        "x": lambda z: get_x(z + 1),\n        "y": lambda z: z\n    },\n    {\n        "direction": "SOUTH",\n        "x": lambda z: z,\n        "y": lambda z: get_y(z + 1)\n    },\n    {\n        "direction": "WEST",\n        "x": lambda z: get_x(z - 1),\n        "y": lambda z: z\n    }\n]\n\n# list of tactics\ntactics = [\n    # N -> E -> S -> W\n    {"directions": get_directions(0, 1, 2, 3)},\n    # S -> E -> N -> W\n    {"directions": get_directions(2, 1, 0, 3)},\n    # N -> W -> S -> E\n    {"directions": get_directions(0, 3, 2, 1)},\n    # S -> W -> N -> E\n    {"directions": get_directions(2, 3, 0, 1)},\n    # E -> N -> W -> S\n    {"directions": get_directions(1, 0, 3, 2)},\n    # W -> S -> E -> N\n    {"directions": get_directions(3, 2, 1, 0)},\n    # E -> S -> W -> N\n    {"directions": get_directions(1, 2, 3, 0)},\n    # W -> N -> E -> S\n    {"directions": get_directions(3, 0, 1, 2)},\n]\ntactics_amount = len(tactics)\n\n\ndef swarm_agent(obs, config):\n    global ship_spawn_turn\n    global tactics_index\n    if globals_not_defined:\n        define_some_globals(config)\n    actions = {}\n    my_halite = obs.players[obs.player][0]\n    \n    reset_game_map(obs)\n    my_shipyards_coords, my_ships_coords = get_my_units_coords_and_update_game_map(obs)\n\n    ships_keys = list(obs.players[obs.player][2].keys())\n    ships_values = list(obs.players[obs.player][2].values())\n    shipyards_keys = list(obs.players[obs.player][1].keys())\n\n#     return {ships_keys[0]: "CONVERT"}\n\n\n    \n    # if there is no shipyards, make one\n    if len(shipyards_keys) == 0 and (my_halite >= conf.convertCost or ships_values[0][1] >= convert_plus_spawn_cost):\n        actions[ships_keys[0]] = "CONVERT"\n\n    else:\n        # if (there are no ships or there is only one shipyard)     and         enough halite to spawn at least one ship\n        #  make ships !\n        \n        if (len(ships_keys) == 0 or len(shipyards_keys) == 1) and my_halite >= conf.spawnCost:\n            ship_spawn_turn = obs.step + turns_to_next_wave_of_ships\n            for i in range(len(my_shipyards_coords)):\n                if my_halite >= conf.spawnCost:\n                    x = my_shipyards_coords[i][0]\n                    y = my_shipyards_coords[i][1]\n                    if clear(x, y, obs.player):\n                        my_halite -= conf.spawnCost\n                        actions[shipyards_keys[i]] = "SPAWN"\n                        game_map[x][y]["ship"] = obs.player\n                        \n        # if it is time to spawn another wave of ships and there is enough halite to spawn at least one ship\n        elif obs.step >= ship_spawn_turn and my_halite >= conf.spawnCost and obs.step < RETURN_HOME:\n            for i in range(len(my_shipyards_coords)):\n                if my_halite >= conf.spawnCost:\n                    x = my_shipyards_coords[i][0]\n                    y = my_shipyards_coords[i][1]\n                    if clear(x, y, obs.player):\n                        my_halite -= conf.spawnCost\n                        actions[shipyards_keys[i]] = "SPAWN"\n                        game_map[x][y]["ship"] = obs.player\n                else:\n                    ship_spawn_turn += turns_to_next_wave_of_ships\n                    break\n        \n        # actions of ships\n        for i in range(len(my_ships_coords)):\n            x = my_ships_coords[i][0]\n            y = my_ships_coords[i][1]\n            \n            # if this is a new ship\n            if ships_keys[i] not in ships_data:\n                ships_data[ships_keys[i]] = {\n                    "moves_done": 0, "ship_max_moves": 1,\n                    "directions": tactics[tactics_index]["directions"], "directions_index": 0 }\n                tactics_index = (tactics_index + 1) % tactics_amount\n                    \n            # if ship has enough halite to convert to shipyard and not at halite source\n            # or ship has two times convert_plus_spawn_cost amount of halite\n            elif ((ships_values[i][1] >= convert_plus_spawn_cost and game_map[x][y]["halite"] == 0) or\n                    ships_values[i][1] >= (convert_plus_spawn_cost * 2)):\n                actions[ships_keys[i]] = "CONVERT"\n                game_map[x][y]["ship"] = None\n                \n            # if this cell has low amount of halite or enemy ship is near\n            elif game_map[x][y]["halite"] < low_amount_of_halite or enemy_ship_near(x, y, obs.player): \n                actions = move_ship(x, y, ships_keys[i], actions, obs.player, len(ships_keys))\n            \n            # IF TIME TO RETURN HOME AND DEPOSIT\n#             print(ships_values)\n            \n            if ( (obs.step > RETURN_HOME) and \n                  (  (ships_values[i][1] > MIN_FINAL_DROPOFF) or \n                           (ships_values[i][1] >  np.percentile( [s[1] for s in ships_values], 80) ) )\n               or    (ships_values[i][1] > MUST_DROPOFF  ) ):\n#                 print()\n                # locate nearest shipyard\n                if len(my_shipyards_coords) > 0:\n                    closest_yard, min_dist = findNearestYard(my_shipyards_coords, x, y)\n                    # move that way as long as don\'t collide with a ship\n                    actions = moveTo(x, y, *my_shipyards_coords[closest_yard], ships_keys[i], obs.player, actions)\n\n                    \n#     if obs.step % 50 == 0:\n#                 print(obs.step)\n    return actions')


# In[ ]:


get_ipython().run_cell_magic('writefile', 'swarm_v8.py', '# for Debug/Train previous line should be commented out, uncomment to write submission.py\n\ndef reset_game_map(obs):\n    """ redefine game_map as two dimensional array of objects and set amounts of halite in each cell """\n    global game_map\n    game_map = []\n    for x in range(conf.size):\n        game_map.append([])\n        for y in range(conf.size):\n            game_map[x].append({\n                # value will be ID of owner\n                "shipyard": None,\n                # value will be ID of owner\n                "ship": None,\n                # amount of halite\n                "halite": obs.halite[conf.size * y + x]\n            })\n\ndef get_my_units_coords_and_update_game_map(obs):\n    """ get lists of coords of my units and update locations of ships and shipyards on the map """\n    # arrays of (x, y) coords\n    my_shipyards_coords = []\n    my_ships_coords = []\n    \n    for player in range(len(obs.players)):\n        shipyards = list(obs.players[player][1].values())\n        for shipyard in shipyards:\n            x = shipyard % conf.size\n            y = shipyard // conf.size\n            # place shipyard on the map\n            game_map[x][y]["shipyard"] = player\n            if player == obs.player:\n                my_shipyards_coords.append((x, y))\n        \n        ships = list(obs.players[player][2].values())\n        for ship in ships:\n            x = ship[0] % conf.size\n            y = ship[0] // conf.size\n            # place ship on the map\n            game_map[x][y]["ship"] = player\n            if player == obs.player:\n                my_ships_coords.append((x, y))\n    return my_shipyards_coords, my_ships_coords\n\ndef get_x(x):\n    """ get x, considering donut type of the map """\n    if x >= conf.size:\n        x -= conf.size\n    elif x < 0:\n        x += conf.size\n    return x\n\ndef get_y(y):\n    """ get y, considering donut type of the map """\n    if y >= conf.size:\n        y -= conf.size\n    elif y < 0:\n        y += conf.size\n    return y\n\ndef clear(x, y, player):\n    """ check if cell is safe to move in """\n    # if there is no shipyard, or there is player\'s shipyard\n    # and there is no ship\n    if ((game_map[x][y]["shipyard"] == player or game_map[x][y]["shipyard"] == None) and\n            game_map[x][y]["ship"] == None):\n        return True\n    return False\n\ndef move_ship(x_initial, y_initial, ship_id, action, player, ships_amount):\n    """ \n        ship will move in expanding circles clockwise or counterclockwise\n        until reaching maximum radius, then radius will be minimal again\n    """\n    directions = ships_data[ship_id]["directions"]\n    # set index of direction\n    i = ships_data[ship_id]["directions_index"]\n    for j in range(len(directions)):\n        x = directions[i]["x"](x_initial)\n        y = directions[i]["y"](y_initial)\n        # if cell is ok to move in\n        if (((clear(x, y, player) or (ships_amount > 10 and game_map[x][y]["ship"] == None)) and not enemy_ship_near(x, y, player)) or\n                (ships_amount > 30 and game_map[x][y]["ship"] != player)):\n            ships_data[ship_id]["moves_done"] += 1\n            # apply changes to game_map, to avoid collisions of player\'s ships next turn\n            game_map[x_initial][y_initial]["ship"] = None\n            game_map[x][y]["ship"] = player\n            # if it was last move in this direction\n            if ships_data[ship_id]["moves_done"] >= ships_data[ship_id]["ship_max_moves"]:\n                ships_data[ship_id]["moves_done"] = 0\n                ships_data[ship_id]["directions_index"] += 1\n                # if it is last direction in a list\n                if ships_data[ship_id]["directions_index"] >= len(directions):\n                    ships_data[ship_id]["directions_index"] = 0\n                    ships_data[ship_id]["ship_max_moves"] += 1\n                    # if ship_max_moves reached maximum radius expansion\n                    if ships_data[ship_id]["ship_max_moves"] >= max_moves_amount:\n                        ships_data[ship_id]["ship_max_moves"] = 1\n            action[ship_id] = directions[i]["direction"]\n            break\n        else:\n            # loop through directions\n            i += 1\n            if i >= len(directions):\n                i = 0\n    return action\n\ndef get_directions(i0, i1, i2, i3):\n    """ get list of directions in a certain sequence """\n    return [directions[i0], directions[i1], directions[i2], directions[i3]]\n\ndef enemy_ship_near(x, y, player):\n    """ check if enemy ship is in one move away from game_map[x][y] """\n    if (\n            (game_map[x][get_y(y - 1)]["ship"] != player and game_map[x][get_y(y - 1)]["ship"] != None) or\n            (game_map[x][get_y(y + 1)]["ship"] != player and game_map[x][get_y(y + 1)]["ship"] != None) or\n            (game_map[get_x(x + 1)][y]["ship"] != player and game_map[get_x(x + 1)][y]["ship"] != None) or\n            (game_map[get_x(x - 1)][y]["ship"] != player and game_map[get_x(x - 1)][y]["ship"] != None)\n        ): return True\n    return False\n\ndef define_some_globals(config):\n    """ define some of the global variables """\n    global conf\n    global turns_to_next_wave_of_ships\n    global convert_plus_spawn_cost\n    global max_moves_amount\n    global globals_not_defined\n    conf = config\n    turns_to_next_wave_of_ships = conf.size // 2\n    convert_plus_spawn_cost = conf.convertCost + conf.spawnCost\n    max_moves_amount = conf.size // 2\n    globals_not_defined = False\n\n\n############################################################################\nconf = None\n# game_map will be two dimensional array of objects\ngame_map = []\n# object with ship ids and their data\nships_data = {}\n# amount of turns to pass before spawning new ships\nturns_to_next_wave_of_ships = None\n# initial tactics index\ntactics_index = 0\n# amount of halite, that is considered to be low\nlow_amount_of_halite = 200\n# sum of conf.convertCost and conf.spawnCost\nconvert_plus_spawn_cost = None\n# number of the turn at which new wave of ships will be spawned\nship_spawn_turn = 0\n# max amount of moves in one direction before turning\nmax_moves_amount = None\n# not all global variables are defined\nglobals_not_defined = True\n\n# list of directions\ndirections = [\n    {\n        "direction": "NORTH",\n        "x": lambda z: z,\n        "y": lambda z: get_y(z - 1)\n    },\n    {\n        "direction": "EAST",\n        "x": lambda z: get_x(z + 1),\n        "y": lambda z: z\n    },\n    {\n        "direction": "SOUTH",\n        "x": lambda z: z,\n        "y": lambda z: get_y(z + 1)\n    },\n    {\n        "direction": "WEST",\n        "x": lambda z: get_x(z - 1),\n        "y": lambda z: z\n    }\n]\n\n# list of tactics\ntactics = [\n    # N -> E -> S -> W\n    {"directions": get_directions(0, 1, 2, 3)},\n    # S -> E -> N -> W\n    {"directions": get_directions(2, 1, 0, 3)},\n    # N -> W -> S -> E\n    {"directions": get_directions(0, 3, 2, 1)},\n    # S -> W -> N -> E\n    {"directions": get_directions(2, 3, 0, 1)},\n    # E -> N -> W -> S\n    {"directions": get_directions(1, 0, 3, 2)},\n    # W -> S -> E -> N\n    {"directions": get_directions(3, 2, 1, 0)},\n    # E -> S -> W -> N\n    {"directions": get_directions(1, 2, 3, 0)},\n    # W -> N -> E -> S\n    {"directions": get_directions(3, 0, 1, 2)},\n]\ntactics_amount = len(tactics)\n\ndef swarm_agent(obs, config):\n    global ship_spawn_turn\n    global tactics_index\n    if globals_not_defined:\n        define_some_globals(config)\n    action = {}\n    my_halite = obs.players[obs.player][0]\n    \n    reset_game_map(obs)\n    my_shipyards_coords, my_ships_coords = get_my_units_coords_and_update_game_map(obs)\n\n    ships_keys = list(obs.players[obs.player][2].keys())\n    ships_values = list(obs.players[obs.player][2].values())\n    shipyards_keys = list(obs.players[obs.player][1].keys())\n    \n    # if there is no shipyards\n    if len(shipyards_keys) == 0 and (my_halite >= conf.convertCost or ships_values[0][1] >= convert_plus_spawn_cost):\n        action[ships_keys[0]] = "CONVERT"\n    else:\n        # if there is no ships or only one shipyard and enough halite to spawn at least one ship\n        if (len(ships_keys) == 0 or len(shipyards_keys) == 1) and my_halite >= conf.spawnCost:\n            ship_spawn_turn = obs.step + turns_to_next_wave_of_ships\n            for i in range(len(my_shipyards_coords)):\n                if my_halite >= conf.spawnCost:\n                    x = my_shipyards_coords[i][0]\n                    y = my_shipyards_coords[i][1]\n                    if clear(x, y, obs.player):\n                        my_halite -= conf.spawnCost\n                        action[shipyards_keys[i]] = "SPAWN"\n                        game_map[x][y]["ship"] = obs.player\n        # if it is time to spawn another wave of ships and there is enough halite to spawn at least one ship\n        elif obs.step >= ship_spawn_turn and my_halite >= conf.spawnCost:\n            for i in range(len(my_shipyards_coords)):\n                if my_halite >= conf.spawnCost:\n                    x = my_shipyards_coords[i][0]\n                    y = my_shipyards_coords[i][1]\n                    if clear(x, y, obs.player):\n                        my_halite -= conf.spawnCost\n                        action[shipyards_keys[i]] = "SPAWN"\n                        game_map[x][y]["ship"] = obs.player\n                else:\n                    ship_spawn_turn += turns_to_next_wave_of_ships\n                    break\n        \n        # actions of ships\n        for i in range(len(my_ships_coords)):\n            x = my_ships_coords[i][0]\n            y = my_ships_coords[i][1]\n            # if this is a new ship\n            if ships_keys[i] not in ships_data:\n                ships_data[ships_keys[i]] = {\n                    "moves_done": 0,\n                    "ship_max_moves": 1,\n                    "directions": tactics[tactics_index]["directions"],\n                    "directions_index": 0\n                }\n                tactics_index += 1\n                if tactics_index >= tactics_amount:\n                    tactics_index = 0\n            # if ship has enough halite to convert to shipyard and not at halite source\n            # or ship has two times convert_plus_spawn_cost amount of halite\n            elif ((ships_values[i][1] >= convert_plus_spawn_cost and game_map[x][y]["halite"] == 0) or\n                    ships_values[i][1] >= (convert_plus_spawn_cost * 2)):\n                action[ships_keys[i]] = "CONVERT"\n                game_map[x][y]["ship"] = None\n            else:\n                # if this cell has low amount of halite or enemy ship is near\n                if game_map[x][y]["halite"] < low_amount_of_halite or enemy_ship_near(x, y, obs.player):\n                    action = move_ship(x, y, ships_keys[i], action, obs.player, len(ships_keys))\n    return action')


# In[ ]:





# # Debug/Train your Agent

# In[ ]:


if "swarm_agent" in globals():
    # reset variables
    ships_data = {}
    tactics_index = 0

    # Play as first position against random agent.
    trainer = env.train([None, "random"])

    observation = trainer.reset()

    while not env.done:
        my_action = swarm_agent(observation, env.configuration)
        print("Step: {0}, My Action: {1}".format(observation.step, my_action))
        observation, reward, done, info = trainer.step(my_action)
        # env.render(mode="ipython", width=100, height=90, header=False, controls=False)
    env.render()


# # Evaluate your Agent

# In[ ]:


def mean_reward(rewards):
    wins = 0
    ties = 0
    loses = 0
    for r in rewards:
        r0 = 0 if r[0] is None else r[0]
        r1 = 0 if r[1] is None else r[1]
        if r0 > r1:
            wins += 1
        elif r1 > r0:
            loses += 1
        else:
            ties += 1
    return f'wins={wins/len(rewards)}, ties={ties/len(rewards)}, loses={loses/len(rewards)}'


# In[ ]:





# ### Run Tests

# In[ ]:


import datetime as datetime
import random


# In[ ]:


OTHERS = ['swarm_v8.py']

start = datetime.datetime.now()

#env.run(["submission.py", "submission.py", "submission.py", "submission.py"])
env.run(["submission.py", random.choice(OTHERS), random.choice(OTHERS), "submission.py"])
env.render(mode="ipython", width=800, height=600)

# print('Time Elapsed: ', (datetime.datetime.now() - start).seconds, )
# In[ ]:





# In[ ]:


start = datetime.datetime.now()
# Run multiple episodes to estimate its performance.
# Setup agentExec as LOCAL to run in memory (runs faster) without process isolation.
print("Swarm Agent vs Prior Agent:", mean_reward(evaluate(
    "halite",
    ["submission.py", random.choice(OTHERS), random.choice(OTHERS), random.choice(OTHERS)],
    num_episodes=10, configuration={"agentExec": "LOCAL"}
)))

print('Time Elapsed: ', (datetime.datetime.now() - start).seconds, )

