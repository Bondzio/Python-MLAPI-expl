#!/usr/bin/env python
# coding: utf-8

# # Install kaggle-environments

# In[ ]:


# 1. Enable Internet in the Kernel (Settings side pane)

# 2. Curl cache may need purged if v0.1.6 cannot be found (uncomment if needed). 
# !curl -X PURGE https://pypi.org/simple/kaggle-environments

# Halite environment was defined in v0.2.1
get_ipython().system("pip install 'kaggle-environments>=0.2.1'")


# # Create Halite Environment

# In[ ]:


from kaggle_environments import evaluate, make

env = make("halite", debug=True)
env.render()


# # Create a Submission (agent)

# In[ ]:


get_ipython().run_cell_magic('writefile', 'submission.py', '# for Debug previous line (%%writefile submission.py) should be commented out, uncomment to write submission.py\n\nimport random\n\n#FUNCTIONS###################################################\ndef get_map_and_average_rum(obs):\n    """\n        get average amount of rum per rum distillery\n        and map as two dimensional array of dictionaries and set amounts of rum in each sector\n    """\n    game_map = []\n    rum_distilleries_amount = 0\n    rum_total_amount = 0\n    for x in range(conf.size):\n        game_map.append([])\n        for y in range(conf.size):\n            game_map[x].append({\n                # value will be ID of tavern\n                "tavern_name": None,\n                # value will be ID of kaptin\n                "tavern_kaptin": None,\n                # value will be ID of ship\n                "ship_name": None,\n                # value will be ID of kaptin\n                "ship_kaptin": None,\n                # value will be amount of rum in ship\'s cargo hold\n                "ship_cargo": None,\n                # amount of rum in this sector\n                "rum": obs["rum"][conf.size * y + x]\n            })\n            # count rum distilleries\n            if game_map[x][y]["rum"] > 0:\n                rum_total_amount += game_map[x][y]["rum"]\n                rum_distilleries_amount += 1\n    # average amount of rum on the map\n    average_rum = rum_total_amount / rum_distilleries_amount\n    return game_map, average_rum\n\ndef update_map(ph_env):\n    """ update locations of ships and taverns on the map """\n    # place on the map locations of ships and taverns of every kaptin\n    for kaptin in range(len(ph_env["obs"]["kaptins"])):\n        # place on the map locations of every tavern of the kaptin\n        taverns = list(ph_env["obs"]["kaptins"][kaptin][1].values())\n        for t in range(len(taverns)):\n            x = taverns[t] % conf.size\n            y = taverns[t] // conf.size\n            # place tavern on the map\n            ph_env["map"][x][y]["tavern_kaptin"] = kaptin\n            # if it\'s your tavern, write its unique name on the map\n            if kaptin == ph_env["obs"]["kaptin"]:\n                ph_env["map"][x][y]["tavern_name"] = ph_env["taverns_names"][t]\n        # place on the map locations of every ship of the kaptin\n        ships = list(ph_env["obs"]["kaptins"][kaptin][2].values())\n        for s in range(len(ships)):\n            x = ships[s][0] % conf.size\n            y = ships[s][0] // conf.size\n            # place ship on the map\n            ph_env["map"][x][y]["ship_kaptin"] = kaptin\n            ph_env["map"][x][y]["ship_cargo"] = ships[s][1]\n            # if it\'s your ship, write its unique name on the map\n            if kaptin == ph_env["obs"]["kaptin"]:\n                ph_env["map"][x][y]["ship_name"] = ph_env["ships_names"][s]\n\ndef get_c(c):\n    """ get coordinate, considering donut type of the map """\n    return c % conf.size\n\ndef enemy_ships_one_step(x_initial, y_initial, kaptin, m):\n    """ get how many enemy ships are one step away from ph_env["map"][x][y] """\n    # m = game map\n    enemy_ships_amount = 0\n    for d in directions:\n        x = directions[d]["x"](x_initial)\n        y = directions[d]["y"](y_initial)\n        if m[x][y]["ship_kaptin"] != kaptin and m[x][y]["ship_kaptin"] != None:\n            enemy_ships_amount += 1\n    return enemy_ships_amount\n\ndef good_place_for_tavern(x, y, ph_env):\n    """ find good place to build a tavern """\n    # if there is no taverns around\n    if (ph_env["map"][x][y]["tavern_kaptin"] == None and\n            ph_env["map"][get_c(x + 1)][y]["tavern_kaptin"] == None and\n            ph_env["map"][get_c(x - 1)][y]["tavern_kaptin"] == None and\n            ph_env["map"][x][get_c(y + 1)]["tavern_kaptin"] == None and\n            ph_env["map"][x][get_c(y - 1)]["tavern_kaptin"] == None and\n            ph_env["map"][get_c(x + 1)][get_c(y + 1)]["tavern_kaptin"] == None and\n            ph_env["map"][get_c(x - 1)][get_c(y - 1)]["tavern_kaptin"] == None and\n            ph_env["map"][get_c(x - 1)][get_c(y + 1)]["tavern_kaptin"] == None and\n            ph_env["map"][get_c(x + 1)][get_c(y - 1)]["tavern_kaptin"] == None and\n            ph_env["map"][get_c(x + 2)][y]["tavern_kaptin"] == None and\n            ph_env["map"][get_c(x - 2)][y]["tavern_kaptin"] == None and\n            ph_env["map"][x][get_c(y + 2)]["tavern_kaptin"] == None and\n            ph_env["map"][x][get_c(y - 2)]["tavern_kaptin"] == None):\n        rum_distilleries_amount = 0\n        # count amount of distilleries around\n        for d in directions:\n            if ph_env["map"][directions[d]["x"](x)][directions[d]["y"](y)]["rum"] > 0:\n                rum_distilleries_amount += 1\n        if rum_distilleries_amount >= 3:\n            return True\n    return False\n\ndef drifting(actions, ship, ph_env):\n    """ send ship drifting in search for a good place for a tavern """\n    # if ship is already at that good place for a tavern\n    if good_place_for_tavern(ship["x"], ship["y"], ph_env):\n        ship["here_be_tavern"] = True\n        return actions, ship\n    to_x = None\n    to_y = None\n    dir_to_go = None\n    keys = list(directions.keys())\n    # go in random direction\n    random.shuffle(keys)\n    for key in keys:\n        x = directions[key]["x"](ship["x"])\n        y = directions[key]["y"](ship["y"])\n        # if there is no ship or tavern\n        if (ph_env["map"][x][y]["ship_kaptin"] == None and\n                ph_env["map"][x][y]["tavern_kaptin"] == None):\n            to_x = x\n            to_y = y\n            dir_to_go = key\n            # if it is good place for a tavern\n            if good_place_for_tavern(x, y, ph_env):\n                ship["x"] = to_x\n                ship["y"] = to_y\n                actions[ship["name"]] = dir_to_go\n                return actions, ship\n    # if good place for a tavern has been found\n    if dir_to_go != None:\n        ship["x"] = to_x\n        ship["y"] = to_y\n        actions[ship["name"]] = dir_to_go\n    return actions, ship\n\ndef define_some_globals(configuration):\n    """ define some of the global variables """\n    global conf\n    global new_fleet_cost\n    global fleets_steps_threshold\n    global min_rum_steps_threshold\n    global min_rum_to_collect\n    global globals_not_defined\n    conf = configuration\n    new_fleet_cost = conf.spawnCost * 2 + conf.convertCost\n    fleets_steps_threshold = conf.episodeSteps // 2\n    min_rum_steps_threshold = conf.episodeSteps - 50\n    min_rum_to_collect = conf["maxCellHalite"] - conf["maxCellHalite"] * conf["collectRate"]\n    globals_not_defined = False\n\ndef adapt_environment(observation, configuration):\n    """ adapt environment for the pirate haven """\n    ph_env = {}\n    ph_env["obs"] = observation\n    ph_env["taverns_names"] = list(ph_env["obs"]["kaptins"][ph_env["obs"]["kaptin"]][1].keys())\n    ph_env["ships_names"] = list(ph_env["obs"]["kaptins"][ph_env["obs"]["kaptin"]][2].keys())\n    ph_env["ships_logbooks"] = list(ph_env["obs"]["kaptins"][ph_env["obs"]["kaptin"]][2].values())\n    if globals_not_defined:\n        define_some_globals(configuration)\n        # appoint first ship in a game\n        rogue_ships.append({\n            "name": ph_env["ships_names"][0],\n            "here_be_tavern": False,\n            "rum_reserved_by_this_ship": new_fleet_cost - conf.spawnCost,\n            "x": ph_env["ships_logbooks"][0][0] % conf.size,\n            "y": ph_env["ships_logbooks"][0][0] // conf.size\n        })\n    ph_env["map"], ph_env["average_rum"] = get_map_and_average_rum(ph_env["obs"])\n    ph_env["stored_rum"] = ph_env["obs"]["kaptins"][ph_env["obs"]["kaptin"]][0]\n    update_map(ph_env)\n    if ph_env["obs"]["step"] == fleets_steps_threshold:\n        global fleets_max_amount\n        fleets_max_amount = 1\n    if ph_env["obs"]["step"] == min_rum_steps_threshold:\n        global min_rum_to_collect\n        min_rum_to_collect = 100\n    return ph_env\n\ndef name_keys_properly(scurvy_observation):\n    """ Argh! Name those scurvy observation keys properly! """\n    scurvy_observation["rum"] = scurvy_observation["halite"]\n    scurvy_observation["kaptin"] = scurvy_observation["player"]\n    scurvy_observation["kaptins"] = scurvy_observation["players"]\n    return scurvy_observation\n\ndef actions_of_fleets(ph_env):\n    """ actions of every fleet of the kaptin """\n    actions = {}\n    for i in range(len(fleets))[::-1]:\n        tactics_applied = False\n        for tactics in fleets[i]["tactics"]:\n            tactics_applied, fleets[i], actions = tactics(fleets[i], actions, ph_env)\n            # if tactics successfully applied, don\'t try to apply any other tactics\n            if tactics_applied:\n                break\n        if not tactics_applied:\n            # disband fleet if no tactics could be applied\n            disband_fleet(fleets[i], i)\n    fleet_assembled = True\n    # if possible, assemble new fleets from rogue ships\n    while fleet_assembled and len(rogue_ships) > 0 and len(fleets) < fleets_max_amount:\n        fleet_assembled, actions = assemble_new_fleet(actions, ph_env, [one_guard_one_tavern])\n    return actions\n\ndef assemble_new_fleet(actions, ph_env, tactics_list):\n    """ assemble new fleet and apply first applicable tactics from tactics_list """\n    fleet = {}\n    fleet["tactics"] = tactics_list\n    fleet["ships"] = []\n    fleet["taverns"] = []\n    tactics_applied = False\n    for tactics in fleet["tactics"]:\n        tactics_applied, fleet, actions = tactics(fleet, actions, ph_env)\n        # if tactics successfully applied, don\'t try to apply other tactics from the tactics_list\n        if tactics_applied:\n            break\n    # if no tactics from tactics_list were applied, do not assemble new fleet\n    if not tactics_applied:\n        return False, actions\n    fleets.append(fleet)\n    return True, actions\n    \ndef disband_fleet(fleet, i):\n    """ transfer all existing fleet\'s ships to rogues and disband fleet """\n    rogue_ships.extend(fleet["ships"])\n    fleets.pop(i)\n    \ndef roll_call(ph_env):\n    """ name all nameless and remove all non-existent ships and taverns """\n    global reserved_rum\n    for fleet in fleets:\n        for i in range(len(fleet["ships"]))[::-1]:\n            if fleet["ships"][i]["name"] == None:\n                fleet["ships"][i]["name"] = ph_env["map"][fleet["ships"][i]["x"]][fleet["ships"][i]["y"]]["ship_name"]\n            if fleet["ships"][i]["name"] not in ph_env["ships_names"]:\n                reserved_rum -= fleet["ships"][i]["rum_reserved_by_this_ship"]\n                fleet["ships"].pop()\n        for i in range(len(fleet["taverns"]))[::-1]:\n            if fleet["taverns"][i]["name"] == None:\n                fleet["taverns"][i]["name"] = ph_env["map"][fleet["taverns"][i]["x"]][fleet["taverns"][i]["y"]]["tavern_name"]\n            if fleet["taverns"][i]["name"] not in ph_env["taverns_names"]:\n                reserved_rum -= fleet["taverns"][i]["rum_reserved_by_this_tavern"]\n                fleet["taverns"].pop()\n    for ship in rogue_ships[::-1]:\n        if ship["name"] == None:\n            ship["name"] = ph_env["map"][ship["x"]][ship["y"]]["ship_name"]\n        if ship["name"] not in ph_env["ships_names"]:\n            reserved_rum -= ship["rum_reserved_by_this_ship"]\n            rogue_ships.pop()\n    \n#TACTICS################################################\ndef one_guard_one_tavern(fleet, actions, ph_env):\n    """\n        this tactics requires one tavern and one ship to guard that tavern\n        and collect rum from neighbouring rum distilleries\n    """\n    global reserved_rum\n    # amount of units required for this tactics\n    ships_required = 1\n    taverns_required = 1\n    # if there is currently no ships or taverns in this fleet\n    if len(fleet["ships"]) != ships_required and len(fleet["taverns"]) != taverns_required:\n        # if there are some rogue ships available\n        if len(rogue_ships) > 0:\n            # transfer ship from rogues to this fleet\n            fleet["ships"].append(rogue_ships.pop())\n        # else tactics can\'t be applied\n        else:\n            return False, fleet, actions\n    # if this fleet is currently full of ships and taverns\n    # and there is enough rum to assemble new fleet\n    # and this kaptin has less then max amount of fleets\n    if (len(fleet["taverns"]) == taverns_required and len(fleet["ships"]) == ships_required and\n            (ph_env["stored_rum"] - reserved_rum) >= new_fleet_cost and\n            len(fleets) < fleets_max_amount):\n        fleet["ships"][0]["here_be_tavern"] = False\n        fleet["ships"][0]["rum_reserved_by_this_ship"] = new_fleet_cost - conf.spawnCost\n        # transfer current ship to rogues\n        rogue_ships.append(fleet["ships"].pop())\n        reserved_rum += new_fleet_cost\n    # if there is not enough ships in this fleet\n    if len(fleet["ships"]) != ships_required:\n        # if there is enough taverns in this fleet\n        # and no ship of this kaptin is currently at this tavern\n        # and there is enough rum to build a new ship\n        if (len(fleet["taverns"]) == taverns_required and\n                ph_env["map"][fleet["taverns"][0]["x"]][fleet["taverns"][0]["y"]]["ship_kaptin"] != ph_env["obs"]["kaptin"] and\n                ph_env["stored_rum"] >= conf.spawnCost):\n            ph_env["stored_rum"] -= conf.spawnCost\n            reserved_rum -= conf.spawnCost\n            if reserved_rum < 0:\n                reserved_rum = 0\n            actions[fleet["taverns"][0]["name"]] = "SPAWN"\n            # place ship of this kaptin at this tavern to avoid collisions\n            ph_env["map"][fleet["taverns"][0]["x"]][fleet["taverns"][0]["y"]]["ship_kaptin"] = ph_env["obs"]["kaptin"]\n            # if there is enough rum to assemble new fleet\n            # and this kaptin has less then max amount of fleets\n            # newly built ship will be appointed to rogues and new fleet assembled\n            if ((ph_env["stored_rum"] - reserved_rum) >= new_fleet_cost and\n                    len(fleets) < fleets_max_amount):\n                reserved_rum += new_fleet_cost\n                fleet["taverns"][0]["rum_reserved_by_this_tavern"] = conf.spawnCost\n                rogue_ships.append({\n                    "name": None,\n                    "here_be_tavern": False,\n                    "rum_reserved_by_this_ship": new_fleet_cost - conf.spawnCost,\n                    "x": fleet["taverns"][0]["x"],\n                    "y": fleet["taverns"][0]["y"]\n                })\n                assemble_new_fleet({}, ph_env, [one_guard_one_tavern])\n                return True, fleet, actions\n            # otherwise simply appoint newly built ship to current fleet\n            fleet["taverns"][0]["rum_reserved_by_this_tavern"] = 0\n            fleet["ships"].append({\n                "name": None,\n                "here_be_tavern": False,\n                "rum_reserved_by_this_ship": 0,\n                "x": fleet["taverns"][0]["x"],\n                "y": fleet["taverns"][0]["y"]\n            })\n        return True, fleet, actions\n    ship = fleet["ships"][0]\n    # if there is currently not enough taverns\n    if len(fleet["taverns"]) != taverns_required:\n        # if the ship is named\n        if ship["name"] != None:\n            ph_env["map"][ship["x"]][ship["y"]]["ship_kaptin"] = None\n            # send ship drifting\n            actions, ship = drifting(actions, ship, ph_env)\n            ph_env["map"][ship["x"]][ship["y"]]["ship_kaptin"] = ph_env["obs"]["kaptin"]\n        # if ship is currently at a good place for tavern\n        if ship["here_be_tavern"]:\n            # if there is enough rum to build a tavern\n            if ph_env["stored_rum"] >= conf.convertCost:\n                actions[ship["name"]] = "CONVERT"\n                ph_env["map"][ship["x"]][ship["y"]]["tavern_kaptin"] = ph_env["obs"]["kaptin"]\n                x = ship["x"]\n                y = ship["y"]\n                # subtract cost of a tavern from ship\'s cargo and remaining cost, if any, from stored rum\n                ph_env["map"][x][y]["ship_cargo"] -= conf.convertCost\n                if ph_env["map"][x][y]["ship_cargo"] < 0:\n                    ph_env["stored_rum"] += ph_env["map"][x][y]["ship_cargo"]\n                    ph_env["map"][x][y]["ship_cargo"] = 0\n                ship["rum_reserved_by_this_ship"] = 0\n                reserved_rum -= conf.convertCost\n                if reserved_rum < 0:\n                    reserved_rum = 0\n                ph_env["map"][x][y]["ship_kaptin"] = None\n                fleet["taverns"].append({\n                    "name": None,\n                    "rum_reserved_by_this_tavern": conf.spawnCost,\n                    "x": x,\n                    "y": y\n                })\n        return True, fleet, actions\n    ship_x = ship["x"]\n    ship_y = ship["y"]\n    tavern_x = fleet["taverns"][0]["x"]\n    tavern_y = fleet["taverns"][0]["y"]\n    # if ship is now at the fleet\'s tavern\n    if ship_x == tavern_x and ship_y == tavern_y:\n        # if only one enemy ship is near\n        if enemy_ships_one_step(tavern_x, tavern_y, ph_env["obs"]["kaptin"], ph_env["map"]) == 1:\n            # Shiver me timbers! They\'re pillaging our rum distillery! Board \'em!!!\n            for direction in directions:\n                x = directions[direction]["x"](ship_x)\n                y = directions[direction]["y"](ship_y)\n                # if there is no tavern and hostile kaptin\'s ship has more rum\n                if (ph_env["map"][x][y]["ship_kaptin"] != None and\n                        ph_env["map"][x][y]["tavern_kaptin"] == None and\n                        ph_env["map"][x][y]["ship_kaptin"] != ph_env["obs"]["kaptin"] and\n                        ph_env["map"][x][y]["ship_cargo"] > ph_env["map"][ship_x][ship_y]["ship_cargo"]):\n                    actions[ship["name"]] = direction\n                    ph_env["map"][x][y]["ship_kaptin"] = ph_env["obs"]["kaptin"]\n                    ph_env["map"][ship_x][ship_y]["ship_kaptin"] = None\n                    ship["x"] = x\n                    ship["y"] = y\n                    return True, fleet, actions\n        # if there is no enemy ships near\n        if enemy_ships_one_step(tavern_x, tavern_y, ph_env["obs"]["kaptin"], ph_env["map"]) == 0:\n            # collect that rum before it\'s gone\n            for direction in directions:\n                x = directions[direction]["x"](ship_x)\n                y = directions[direction]["y"](ship_y)\n                # if there is a lot of rum in that direction and no ships in that sector\n                if ph_env["map"][x][y]["rum"] > min_rum_to_collect and ph_env["map"][x][y]["ship_kaptin"] == None:\n                    actions[ship["name"]] = direction\n                    ph_env["map"][x][y]["ship_kaptin"] = ph_env["obs"]["kaptin"]\n                    ph_env["map"][ship_x][ship_y]["ship_kaptin"] = None\n                    ship["x"] = x\n                    ship["y"] = y\n                    return True, fleet, actions\n    # else, if there is low amount of rum in distillery or enemy ship near fleet\'s tavern\n    # go back to the fleet\'s tavern for debauchery\n    elif (ph_env["map"][ship_x][ship_y]["rum"] <= min_rum_to_collect or\n            enemy_ships_one_step(tavern_x, tavern_y, ph_env["obs"]["kaptin"], ph_env["map"])) > 0:\n        for direction in directions:\n            x = directions[direction]["x"](ship_x)\n            y = directions[direction]["y"](ship_y)\n            # if there is current fleet\'s tavern in that direction and none of this kaptin\'s ships\n            if (x == tavern_x and y == tavern_y and\n                    ph_env["map"][x][y]["ship_kaptin"] != ph_env["obs"]["kaptin"]):\n                actions[ship["name"]] = direction\n                ph_env["map"][x][y]["ship_kaptin"] = ph_env["obs"]["kaptin"]\n                ph_env["map"][ship_x][ship_y]["ship_kaptin"] = None\n                ship["x"] = x\n                ship["y"] = y\n                return True, fleet, actions\n    return True, fleet, actions\n\n\n#GLOBAL_VARIABLES#############################################\nconf = None\nfleets_steps_threshold = None\nmin_rum_steps_threshold = None\n# minimal amount of rum at distillery to consider it for collecting\nmin_rum_to_collect = None\n# amount of rum needed to assemble new fleet\n# one ship to convert to tavern, conversion cost, one ship to guard the tavern\nnew_fleet_cost = None\n# list of currently existing fleets\nfleets = []\n# list of ships that doesn\'t belong to any fleet\nrogue_ships = []\n# rum reserved for future debauchery\nreserved_rum = 0\n# maximum amounts of fleets at any step\nfleets_max_amount = 20\n# not all global variables are defined\nglobals_not_defined = True\n\n# dictionary of directions\ndirections = {\n    "NORTH": {\n        "x": lambda z: z,\n        "y": lambda z: get_c(z - 1)\n    },\n    "EAST": {\n        "x": lambda z: get_c(z + 1),\n        "y": lambda z: z\n    },\n    "SOUTH": {\n        "x": lambda z: z,\n        "y": lambda z: get_c(z + 1)\n    },\n    "WEST": {\n        "x": lambda z: get_c(z - 1),\n        "y": lambda z: z\n    }\n}\n\n\n#%Pirate_Haven%####################################################\ndef pirate_haven(scurvy_observation, configuration):\n    """ Yo-ho-ho and a Bottle of Rum!!! """\n    observation = name_keys_properly(scurvy_observation)\n    ph_env = adapt_environment(observation, configuration)\n    roll_call(ph_env)\n    actions = actions_of_fleets(ph_env)\n    return actions')


# # Debug your Agent

# In[ ]:


if "pirate_haven" in globals():
    # reset variables
    conf = None
    fleets_steps_threshold = None
    min_rum_steps_threshold = None
    # minimal amount of rum at distillery to consider it for collecting
    min_rum_to_collect = None
    # amount of rum needed to assemble new fleet
    # one ship to convert to tavern, conversion cost, one ship to guard the tavern
    new_fleet_cost = None
    # list of currently existing fleets
    fleets = []
    # list of ships that doesn't belong to any fleet
    rogue_ships = []
    # rum reserved for future debauchery
    reserved_rum = 0
    # maximum amounts of fleets at any step
    fleets_max_amount = 20
    # not all global variables are defined
    globals_not_defined = True

    # Play as first position against random agent.
    trainer = env.train([None, "random"])

    observation = trainer.reset()

    while not env.done:
        my_action = pirate_haven(observation, env.configuration)
        print("Step: {0}, My Action: {1}".format(observation.step, my_action))
        observation, reward, done, info = trainer.step(my_action)
        # env.render(mode="ipython", width=100, height=90, header=False, controls=False)
    env.render()


# # Evaluate your Agent

# In[ ]:


def mean_reward(rewards):
    wins = 0
    ties = 0
    loses = 0
    for r in rewards:
        r0 = 0 if r[0] is None else r[0]
        r1 = 0 if r[1] is None else r[1]
        if r0 > r1:
            wins += 1
        elif r1 > r0:
            loses += 1
        else:
            ties += 1
    return f'wins={wins/len(rewards)}, ties={ties/len(rewards)}, loses={loses/len(rewards)}'

# Run multiple episodes to estimate its performance.
# Setup agentExec as LOCAL to run in memory (runs faster) without process isolation.
print("Pirate Haven vs Random Agent:", mean_reward(evaluate(
    "halite",
    ["submission.py", "random", "random", "random"],
    num_episodes=10, configuration={"agentExec": "LOCAL"}
)))


# # Test your Agent

# In[ ]:


env.run(["submission.py", "submission.py", "submission.py", "submission.py"])
#env.run(["submission.py", "random", "random", "random"])
env.render(mode="ipython", width=800, height=600)


# # Submit to Competition
# 
# 1. Commit this kernel.
# 2. View the commited version.
# 3. Go to "Data" section and find submission.py file.
# 4. Click "Submit to Competition"
# 5. Go to [My Submissions](https://kaggle.com/c/halite/submissions) to view your score and episodes being played.
