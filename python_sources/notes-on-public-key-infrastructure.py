#!/usr/bin/env python
# coding: utf-8

# ## Everything you should know about certificates and PKI but are too afraid to ask
# 
# This notebook consists of my notes on the blog post ["Everything PKI"](https://smallstep.com/blog/everything-pki.html).

# * Public key infrastructure is a well-known industry-proven best practice for creating unique key value pairs. It underlies how HTTPS works for example, via certs.
# * An **entity** is something that exists.
# * Every **entity** has an **identity**, which consists of a set of **identifiers** ascribed to the entity.
# * An entity may **claim** to have a certain identifier. **Authentication** is about verifying the veracity of claims.
# * A **subscriber** is the subject of a **certificate**. A **certificate authority** issues a **leaf certificate** to a subscriber.
# * CAs have certain **root certificates** that establish their authority for certificate issuance. These are hard-coded. There are usually **intermediate certificates** which have a waterfull trust chain.
# * A **relying party** relies on a trustable certificate attached to a subscriber.
# 
# 
# * In the case where two entities have a shared secret function, they may use that shared function and its inverse to verify incoming messages and encode outgoing messages on the channel of communication between the two entities. The hashed value sent is known as the **message authentication code**, or MAC. Not to be confused with MAC addresses on a machine.
# * The established protocol for doing MAC authentication is known as HMAC.
# * The cryptographic strength of MAC comms depends on the cryptographic strength of the underlying hash functions. E.g. SHA-256 is strong, SHA-1 is weak.
# 
# 
# * **Public key encryption** introduces a **public key** and a **private key**. A public key is a value that can be used to verify the veracity of a message but cannot be used to generate new valid messages. A private key value can be generate new valid messages. Thus the private key is priviledged and the public key is not.
# * Freely handing out public keys but keeping private keys as secrets is how secured PKI systems are built.
# * The public key and private key together may be used to generate a **signature**, which is verifiable by all holders of the public key (e.g. the world) to be a genuine statement on the part of the private key holder.
# * The mathematics is based on the multiplication of two primes being easy to do, but hard to invert (recall that from college?).
# * It boils down to the fact that with a **key pair** there are two things you can do:
#    1. Encrypt some data using the public key. Only the private key may be used to decrypt that data.
#    2. Sign data with the private key, generating a signature. Anyone with the corresponding public key can decode that signature.
# * So this allows:
#   1. Secure communication _from_ a public key holder (anyone) _to_ a corresponding private key holder. E.g. establish a secure connection to a service.
#   2. Verification by a public key holder that a signature at one time generated by a private key holder is correct. E.g. establish that a certificate issued by that service is genuine.
# 
# * On the Internet you earn a HTTPS certificate using (1) and others verify that you are genuine using (2).
# * The real certificates distributed for HTTPS embed numerous other bits of metadata: name, expiration date, etc.
# * The standard for this is known as X.509, and they are what HTTPS over TLS uses. Other communication protocols, like SSH, use different standards.
# * X.509 is the most widespread PKI certificate type and the focus of the article.
# * Because X.509 was designed for use building a global phone book and then adapted for use in the Internet, it has some warts. E.g. the need to include an address and a distinguished name in the certificate, which are not actually consequential to the cert.
# * X.509 uses a message schema known as ASN.1. Also unique to the cert.
# * ASN.1 has the usual suspect data types but also a special data type, an OID or object identifier. OIDs are namespaced identifiers that can be used as hierarchical maps. E.g. 2.5.4.3 means "California". In the case of names they are supposed to be UIDs. It's unclear to me how those UIDs are mapped.
# * ASN.1 specifies no encoding format. In practice a wire format known as DER is near-universially used. DER is a simple linear type-length-value encoding format.
# * DER outputs to binary. Binary is an inefficient transport protocol so it is typically re-packed once again, typically using a base64 encoding known as PEM, which generates messages that look like the following:
# 
# ```
# -----BEGIN CERTIFICATE-----
# MIIBwzCCAWqgAwIBAgIRAIi5QRl9kz1wb+SUP20gB1kwCgYIKoZIzj0EAwIwGzEZ
# MBcGA1UEAxMQTDVkIFRlc3QgUm9vdCBDQTAeFw0xODExMDYyMjA0MDNaFw0yODEx
# MDMyMjA0MDNaMCMxITAfBgNVBAMTGEw1ZCBUZXN0IEludGVybWVkaWF0ZSBDQTBZ
# MBMGByqGSM49AgEGCCqGSM49AwEHA0IABAST8h+JftPkPocZyuZ5CVuPUk3vUtgo
# cgRbkYk7Ong7ey/fM5fJdRNdeW6SouV5h3nF9JvYKEXuoymSNjGbKomjgYYwgYMw
# DgYDVR0PAQH/BAQDAgGmMB0GA1UdJQQWMBQGCCsGAQUFBwMBBggrBgEFBQcDAjAS
# BgNVHRMBAf8ECDAGAQH/AgEAMB0GA1UdDgQWBBRc+LHppFk8sflIpm/XKpbNMwx3
# SDAfBgNVHSMEGDAWgBTirEpzC7/gexnnz7ozjWKd71lz5DAKBggqhkjOPQQDAgNH
# ADBEAiAejDEfua7dud78lxWe9eYxYcM93mlUMFIzbWlOJzg+rgIgcdtU9wIKmn5q
# FU3iOiRP5VyLNmrsQD3/ItjUN1f1ouY=
# -----END CERTIFICATE-----
# ```
# 
# * PEM-encoded certificates conventionally specifiy a `.pem` or `.crt` or `.cer` file extension.
# * There are also envelope formats that place the certificate inside of other data or metadata. These are still _sometimes_ used on the web.
# * PEM supports indicating them in its payload.
# * PEM also supports specifying encryption in the payload:
# 
# ```
# -----BEGIN EC PRIVATE KEY-----
# Proc-Type: 4,ENCRYPTED
# DEK-Info: AES-256-CBC,b3fd6578bf18d12a76c98bda947c4ac9
# 
# qdV5u+wrywkbO0Ai8VUuwZO1cqhwsNaDQwTiYUwohvot7Vw851rW/43poPhH07So
# sdLFVCKPd9v6F9n2dkdWCeeFlI4hfx+EwzXLuaRWg6aoYOj7ucJdkofyRyd4pEt+
# Mj60xqLkaRtphh9HWKgaHsdBki68LQbObLOz4c6SyxI=
# -----END EC PRIVATE KEY-----
# ```
# 
# * This essentially turns certificate verification back into a shared secret (MAC) process. Only a recipient that knows a shared password may decode an encrypted public or private key. This is useless for a public key, but for a private key essentially allows you to use a shared secret to make a message recepient into a key-pair holder, and hence, a certificate authority.
# 
# 
# * Public key infrastructure is an intentionally vague term. Anything that uses public key cryptography to assign trust to things count as a PKI architecture.
# * SSH for example allows you to add public keys to a file, `.ssh/authorized_keys`. By managing keys in a flat list it avoids needing certificates or certificate authorities.
# * PGP uses a web of trust model (lol).
# * Web PKI is not well-adopted for use cases outside of the web. Within an application surface you should implement your own PKI.
# 
# 
# * Trusted **root certificates** are configured in a **trust store**. On macOS the trust store is managed via the keychain. On Linux it's simply a file in `/etc`. Since these files are editable, trusting content delivered over HTTPS requires trusting all administrative users on the machine in question.
# * Root certificates are always **self-signed**, indicating the end of the trust chain.
# * Operating systems ship with their own hard-coded trust store. Apple and Microsoft run their own CA programs. Mozilla's root certification program is open and transparent, and used as a bootstrap by many other trust store implementations.
# * Browsers use a root cert on the machine to sync with their own trusted (and blacklisted) root lists over TLS.
# * Web PKI is only as trusted as the _least trustworthy certificate authority_. CAs can get compromised by state actors, e.g. the NSA...some are straight-up located in authoritative regimes like China. So for conventional traffic web PKI is maybe enough, but for redline traffic it is not.
# * The root CA key is stipulated to be stored on an air-gapped driver locked-down inside of an HSM (hardware security module).
# * Root private keys are only used a handful of times to assign authority to intermediate CAs.
# 
# 
# * The entire authority chain is supposed to be message recieved by the user.
# * A certificate path validation algorithm is used to walk up the chain of validity to the root certificate. This checks additional constraints like expiration dates and the like. Disabling this defeats public key encryption because it creates side-channel attacks.
# 
# 
# * The two hard problems in computer science: cache invalidation and naming things.
# * X.509 includes a name field encoded as the OID, but that name is bunk and is straight-up deprecated in the current living standard. Instead names are supposed to be included using a spec known as SAN, or subject alternative name, which binds to well-understood names: domain names and DNS records, IP URIs, email addresses, and URIs.
# * SAN includes support for wildcards.
# 
# 
# * Anytime you generate a PKI key pair, best practice is to do it on the machine that is going to use the private key. Avoid transmitting that stuff over the wire.
# * Originally the algorithm for generating the key pair was RSA, but there is a slow transition to elliptical curve cryptography algorithms that is still ongoing.
# * Obtaining a certificate from a CA means two things: (1) proving that the subscriber is providing a public key that they have the private key for and (2) verifying that the identity being provided is actually legit.
# * The former is solved with a simple single certificate signing request.
# * The latter is human-in-the-loop and so more complex. There are, in general, three levels of trust placed by the CA in the issue.
# * The lowest level of trust is domain verification, which involves proving that you own a domain name.
# * An intermediate level without strong standardization is organizational verification, which is CA-dependent.
# * The highest level of trust is extended validation, which involves human actions like signed and notarized attenstations by corporate officers, costs potentially thousands of dollars, and gives you a little badge with your corporation name when you visit the page.
# * Thus your level of trust in an EV or DV certificate is dependent on your level of trust in the challenge a CA issues for verification. This is a pretty easily spoofed bar. It's been broken through before. The article mentions specifically: https://doublepulsar.com/hijack-of-amazons-internet-domain-service-used-to-reroute-web-traffic-for-two-hours-unnoticed-3a6f0dda6a6f.
# 
# 
# * Certificates expire because eternal certificates are an obvious security problem.
# * When a certificate expires the private key associated with that certificate ought to be deleted.
# * However, if a key pair is being used for encryption _also_, that key pair cannot be deleted without losing access to that data!
# * For this reason best practice is to use different key pairs for asymmetric encryption and for asymmetric authentication.
# * There is no mechanism for renewal. Renewal means getting a new cert and doing the dance again.
# * There are mechanisms for revocation, but they don't work well.
# * Instead the trend is towards perform cert issues that cycle quickly enough that you don't _need_ to revoke a cert because it rotates out anyway. You are essentially passing on the security risk to the next layer down in the meantime. This is known as passive revocation.
# * When implementing internal PKI you can set the times to be very low, like every 24 hours. This is essentially what AWS does for example on EC2 roles.
