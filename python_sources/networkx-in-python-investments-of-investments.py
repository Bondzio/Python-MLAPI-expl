#!/usr/bin/env python
# coding: utf-8

# # Using networkX in Python - Investments of investments 

# This was my very first project working with graphs and recursive alogrithms I thought it might be interesting for some of you, therefore sharing it.
# The purpose of the project was to  present a unique algorithm which was needed to calculate costs in a hirearchial stucture. This means that each cost of a parent depended on the status of its previous children, which led the project into a "recursive" world. 
# To achieve this I used networkX to handle the hierarchical relationships, pandas to load the data, and some packages for visualization which helps better understanding the puzzle. 

# # Table of Contents
#  * [Introduction](#introduction)
#  * [ Fund of funds](#FOF)
#     * [The importance of direct costs](#DirectCosts)
#  * [The Problem](#Problem)
#  * [Data & Tools](#Data_and_setup)
#  * [Data load and preparation](#GettingStarted)
#  * [Analyzing the graph](#Graph)
#  * [Solution and algorithm](#Solution)
#  * [Conclusion and checks](#Conclusion)
#  * [Similar Use-cases](#Usecases)

# <a id='introduction'></a>

# ## Introduction:
# 
#  [Funds](https://www.investopedia.com/terms/f/fund.asp) are one of the most well-known "creatures" of the financial world, and they have been around for a while. Their main [purpose](https://en.wikipedia.org/wiki/Investment_fund)  among a lot other is  to invest money and gain advantages as working as part of a group. 
#  
#  This form of investing has a lot of advanteges, however out of those probably the one that remarkably stands out is that, by investing into a fund rather than into a single asset, increases diversification and reduces some systematic risks.
#  
#  Furthermore, once risks are well mitigated, within direct assets that are accessible by the fund, the fund might want to go even further to eliminate risks, and invest some of its remaining assets into other funds thus also making itself able to invest into countries, or firms which are difficult to access directly. 
#   Apart from accessing restricted markets, these funds become less exposed to the volatility of the market in exchange for higher management fees than traditional investments. For more information on [FOFs](https://www.investopedia.com/terms/f/fundsoffunds.asp) (fund of funds) you can visit this link!

# <a id='FOF'></a>

# ## Funds of funds and their recursive problems:
# 
# A fund can basically have two options - it rather decides to invest into assets ([equity](https://www.investopedia.com/terms/e/equity.asp), [bond](https://www.investopedia.com/terms/b/bond.asp), [options](https://www.investopedia.com/terms/o/option.asp)...) or into other funds. 
# Let's imagine a world where we need to report some parameters on these investments. For example costs or returns. For each fund - one part of its calculated parameter will be that it generated by itself via direct investments, and the rest is inherited from those it invested into other funds. However it can easily happen that fund being invested into, further invests into an other one, which invested into an other one, and the line goes on for even to 9 to 10 steps until we get to a single fund which did not decide to invest into any other funds, therefore arriving at the bottom of the graph.
# 
# So for one fund the total cost is: Direct Costs + Inherited Costs
# 
# <a id='DirectCosts'></a>
# ### The importance of direct costs
# 
# Sometimes we receive those costs right sometimes we don't. And when we don't - we know they are wrong, therefore we don't want the wrong costs to be inherited further up the graph (until we correct them), as that would cause serious distortions and would be misleading to flow wrong values through the whole fund-graph. Therefore we need an algorithm which checks, with built-in thresholds whether it is sensible what is just about to happen before each aggregation. 
# 

# <a id='Problem'></a>

# ## The Problem:
# Identify for each fund - how certain we can be about their costs, by making sure the direct cost is calculated correctly, and from the ones it is inheriting it inherites a "big portion" enough to let its costs send further. 
# Within the dataset a single label idientifies whether we believe that direct costs are correctly calculated
# (this is column "approved" - which is binary ("N"/"Y"). 
# The complexity approaches when we look at the inherited part.
# 
#  Let's see a rather simple example: 
# * fund "A" has 3 child investments. 
# * Out of its total assets it invests 70% into funds, the rest into direct assets (30%).
# * Within those children ("B","C","D") it holds 47% 19% and 4%. 
# * "B" and "C" are approved, however something went wrong when calculating the costs of "D". 
# 
# Does this really affect whether we can trust this number?
# Since we concluded in the previous section that:
# For one fund the total cost is: Direct Costs + Inherited Costs
# Accordingly fund "A" has 30% ((for now let's suppose) correctly calculated direct costs) + 66% (4% is not signedd off) cost which comes from inheritance. 
# Since we can assume that most funds have similar costs, that 4% would not make a big difference when added, therefore we should let fund D send its costs further to A, and mark A as only 96% approved. 
# So when it comes to the next level, we don't handle fund "A" as totally completed but somewhere near to that.
# 
# The story goes on:
# * Fund "X" invests into fund "A" 97% of its assets and the remainig 2% into "D" which we already know that is wrong, 1% into fund "K" which is also wrong.
# "X"_signedoff = 0.96*0.97 = 0.9312
# The level of distortion becomes too large - since A was not fully correct. X invests such a big portion into A that we require A to have a bigger precision to mark X as signed off as well, this is simply caused by A's unapproved fund ("D"). 
# 
# *For some further explanation of the problem scroll to the bottom visualizations of the kernel - the visualizations lead through 3 common scnearios*
# 

# <a id='Data_and_setup'></a>

# 
# ## Attributes within data set
# * Fund (or portfolio) - which are single investments I will refer to them as nodes in the further sections
# * parent_fund a fund which has child fund investments
# * child_fund - a portfolio which is being invested into
# * weight - the portion (out of total investments) of how much a fund is investing into its child
# * cost - direct cost generated by direct investments within the fund
# 
# ### Python
#  Python 3.6.4
# If you are unfamiliar with Python or need help with installation: 
# * [Anaconda](https://www.anaconda.com/download/) comes with Python (anaconda is the package manager, which comes with a lot of pre-installed packages, if you are more experienced and prefer to pick packages manually you can use [Miniconda](https://conda.io/miniconda.html))
# * For IDE:
#     * Anaconda installs Jupyter Notebook automatically where you can get started right away
#     * I personally perfer to use [PyCharm](https://www.jetbrains.com/pycharm/download/#section=windows)
# 
# *If you have no experience in Python, PyCharm will be very helpful to have small successes from the very beginning.*
# 
# 
# ### Package requirements:
# * networkx - 2.1 
#   (if you are using previous versions, most of the functions (successors, predecessors) will return lists, so there is no need for conversion)
# * matplotlib
# * pandas
# * seaborn
#  

# <a id='GettingStarted'></a>

# ## Getting Started
# 
# Fist I imported all the required packages, and set up the style for the visualizations, then loaded the necessary files, to work with. 
# 
# 1. I imported the file which contained the necessary information about the "edges". Which fund invests into which fund, and what percentage out of its total assets. Apart from raw data, I created a dataframe, which is called "fundpositions_frame", its single purpose is to calculate for each fund, how much it holds in fund investments. (The rest is obviously held in direct investments). This information is needed when calculations are performed within the graph (fund structure).
# 2. ApprovedFile - contains the information on costs, and whether we believe we calculated those costs correctly. 
# 
# After performing the "join" (merge) with the two frames, we have one single dataframe which allows us to load in all the necessary information into a graph. These are:
#   * Edges (A invests into B)
#   * Weights (A invests into B 50% of its total assets)
#   * (Direct) Costs (not only the parent funds have costs!)
#   * Out of total assets percentage of invested into funds - "total_fund_part"
# 

# In[ ]:


import networkx as nx
import matplotlib.pyplot as plt
import pandas as pd
from pylab import rcParams
import seaborn as sb
import numpy as np


# In[ ]:


get_ipython().run_line_magic('matplotlib', 'inline')
rcParams['figure.figsize'] = 16,16
sb.set_style('whitegrid')


# In[ ]:


path_for_input = '../input/input-file/test_data3.csv'
inputfile = pd.read_csv(path_for_input,header=0,sep=',')
inputfile.head(15)


# In[ ]:


fundpositions_frame = inputfile.groupby(['parent_fund'])['weight'].sum().reset_index()
fundpositions_frame = fundpositions_frame.rename(columns={'weight': 'total_fund_part'})
fundpositions_frame.head(3)


# I joined back the dataframe to the original one, therefore it is easy to calculate from now on, that out of the total inheritable part, how much is ready to be sent further. 
# 
# **Kaggle added here an additional column after the merge - which is called key_0 this prevents the dataframe from performing further joins. 
# In any other environment I ran  this code, this addtional column did not appear - so you might need to remove it from the list of columns which are to be dropped, if you are running this in a different environment**

# In[ ]:


start_frame = pd.merge(inputfile,fundpositions_frame, how='left',left_on = inputfile.parent_fund
                      , right_on=fundpositions_frame.parent_fund, suffixes= ("","_y"))
start_frame = start_frame.drop(['parent_fund_y','key_0'],axis=1)
start_frame


# The file is imported, which contains the information about the direct costs - whether the direct costs have been found correct or not. 

# In[ ]:


path_for_approved = '../input/cost-set/cost3.csv'
approved_file= pd.read_csv(path_for_approved,header=0,sep=',')
approved_file.head(5)


# ### Last steps in preparation:
# I filled up the "total_fund_part" attribute for those funds which have no child holdings.
# #### Results
# The result of the joins is a table, where the fund column is populated in each row, these will be used when loading nodes into the graph, where the child_fund column is not empty I picked the edges for the dataframe. 
# It might look a bit disorganized, but at least one loop solves the creation of our inital graph. 

# In[ ]:


final_frame = pd.DataFrame()
final_frame = pd.merge(start_frame, approved_file, left_on = start_frame.parent_fund, right_on = approved_file.fund, how='outer')
# leaves are missing total fund part - therefore backfilling them with 0s
final_frame.total_fund_part = final_frame.total_fund_part.fillna(0)


# ### Loading the data
# 
# First - I created the initial graph and loaded in the data from the pandas dataframe. 
# I chose to use a directed graph, as the edges symbolize investments - investments are directed, one fund places money into another.
# Networkx allows to load further attributes "behind" the nodes and the edges.
# To make it more simple to handle the approval of direct costs I updated the binarly labels - Y = 1 and N = 0 from now on.
# 
# *The load is done with a single [iteration](http://pandas.pydata.org/pandas-docs/version/0.17.0/generated/pandas.DataFrame.iterrows.html) on the frame, within the loop the add_edge function adds the nodes in the same time, the rest is only adding further attributes from the frame which are used in the calculations later on.*
# 

# In[ ]:


G = nx.DiGraph()
for index, row in final_frame.iterrows():
    if pd.isnull(row['child_fund']) == False:
        G.add_edge(row['fund'],row['child_fund'],weight=row['weight'])
    G.node[row['fund']]['total_fund_part'] = row['total_fund_part']
    G.node[row['fund']]['direct_cost'] = row['cost']
    if row['approved'] == 'N':
        G.node[row['fund']]['direct_approved'] = 0
    else:
        G.node[row['fund']]['direct_approved'] = 1


# <a id='Graph'></a>

# ### Discovering the portfolios
# In the initial file, there are multiple portfolios and funds, however it makes testing and checking a lot easier if one is picked out from the "forest" and follow what happens with it step by step.
# 
# For that - I collected all nodes which are connected to the chosen portfolio, added them to a list, then created the subgraph of the original graph, therefore the focus is on one single portfolio.
# 
# *The loop below collects some information which I found useful when looking at the chosen portfolio ("A"). The nx.has_path opeartion includes in the path the starting node, which I didn't need as we knew we configured the loop to look at "A". *

# In[ ]:


graph_information = []
nodelist = []
portfolio = 'A'
nodelist.append(portfolio)
for n in G.nodes():
    if nx.has_path(G, portfolio , n) == True and portfolio != n:
        length = nx.shortest_path_length(G, portfolio, n)
        short_path = nx.shortest_path(G,portfolio,n)
        graph_information.append([portfolio,n,length,short_path[1:]])
        nodelist.append(n) # this is the new scope


# In[ ]:


a = pd.DataFrame(graph_information, columns=['portfolio','child','num_of_steps','short_path'])
a.head(10)


# #### Visualizing the graph
# Below the portfolio structure is shown as a graph. 
# This graph displays all the funds which "A" is investing into, directly or indireclty. 
# The spring layout does not enable the graph to lay out in a hierarchical way, but it does organize the nodes, the weights and the labels to be displayed evenly. 

# In[ ]:


T = G.subgraph(nodelist)            
posT = nx.spring_layout(T)
rcParams['figure.figsize'] = 14,14
nx.draw_networkx_nodes(T,posT,T.nodes(),node_size=300,node_color='b',alpha=0.1)
nx.draw_networkx_edges(T,posT,T.edges(),width=0.8,edge_color='g')
labels = nx.get_node_attributes(T,'direct_approved')
labels2 = nx.get_edge_attributes(T,'weight')
nx.draw_networkx_nodes(T,pos=posT,font_size=14,edge_labels= labels,node_size=300,node_color='b',alpha=0.1)
nx.draw_networkx_labels(T,pos=posT,font_size=14)
nx.draw_networkx_edge_labels(T,pos=posT,font_size=14,edge_labels=labels2)
plt.title("Direct and Indirect investments of A",size=14)
plt.grid(False)
plt.axis('off')
plt.show()


# ### Further Discovering the graph
# As an additional information we can calculate how much impact each node has on the main portfolio we are examining. We can also see how big their impact is on the total. This impact is the weight it affects the portfolio.
# Node "I" also affects the portfolio ("A"), but less significantly as it is investing into it via another portfolio, as a consequence its impact, is the multiplication of the weights to arrive at the parent. 
# 
# Comments for the code:
#  * I prefer to use dictionaries here, instead of calling the edge and node attributes of the graph - it can be done both ways - referring to the 
#  ```python
#  weight_dictionary[edgepairs[0],edgepairs[1]] = G.edges[edgepairs[0],edgepairs[1]]['weight'] 
#  ```
# (this is just a personal preference)
#  * This code part starts with a very simple user-defined function - what it does:
#      * Input is a list  ```  [1,2,3,4,5] ```
#      * Output is a list: ```   [[1,2],[2,3],[3,4],[4,5]] ```
#   
#  * NodeExtra is a list in which I collect all the "valuable" information on the nodes. 
#  These are:
#   * The portfolio A is investing into (child)
#   * The cost of the child
#   * How much is the total fund holding part of "A"
#   * length - the least number of steps it takes from A to get to its direct or indirect holding
#   * Impact - the weights multiplied on the route
#   * Position - is the child portfolio located at the bottom or it has further holdings

# In[ ]:


def create_edgepairs(listin):
    n = 0
    newlist = []
    while n < len(listin)-1:
        newlist.append([listin[n],listin[n+1]])
        n = n+1
    return newlist


weight_dictionary = nx.get_edge_attributes(G, 'weight')
total_fund_part_dictionary = nx.get_node_attributes(G,'total_fund_part')

#Lookup how much the of its total assets the chosen portfolio is investing into funds
if portfolio in total_fund_part_dictionary:
            p_fund_part = total_fund_part_dictionary[portfolio]
else:
            p_fund_part = 'Not Applicable'

node_information = []
for n in G.nodes():
    if nx.has_path(G,portfolio,n ) == True and n != portfolio:
        length = nx.shortest_path_length(G, portfolio,n)
        short_path = nx.shortest_path(G,portfolio,n)
        #collect all possible paths
        pathes = list(nx.all_simple_paths(G,portfolio,n))
        #loop through all possible pathes
        for everypath in pathes:
            edgelist = create_edgepairs(everypath)
        edgelist =  create_edgepairs(short_path)
        for i,edgepairs in enumerate(edgelist):
            if i ==0:
                port_impact = weight_dictionary[edgepairs[0],edgepairs[1]]
            else:
                port_impact = port_impact * weight_dictionary[edgepairs[0],edgepairs[1]]
               
        if len(list(G.successors(n))) == 0:
            leaf = 'Leaf - bottom portfolio'
        else:
            leaf = 'Parent portfolio'
        #check if value is in dictionary
        
        node_information.append([portfolio, n ,G.node[n]['direct_cost'] ,
                                 p_fund_part, port_impact,length, leaf, short_path[1:]])

impact_frame = pd.DataFrame(node_information,columns=['portfolio','child','child_cost','total_fund_part',
                                              'port_impact','steps','position','short_path'])
impact_frame.head(16)


# In[ ]:


cost_portions = impact_frame.port_impact * impact_frame.child_cost
rcParams['figure.figsize'] = 10,8
colors = ['gold','yellowgreen','lightcoral','lightskyblue','lavender','lightpink',
          'aliceblue','palegoldenrod','lavenderblush','navajowhite','lightsalmon','lightblue']
explode = [0,0,0.1,0,0,0,0,0,0,0,0,0]
plt.pie(cost_portions,labels= impact_frame.child,colors=colors,
        shadow=True, 
        startangle = 291,explode = explode)
plt.title("Impact by portfolio",size=15)
plt.axis('equal')
plt.legend(round(impact_frame.port_impact * impact_frame.child_cost,2))
plt.show()


# ## What is wrong with the logic above?
# Although it does present a number with which we can describe as portfolio impacts, it is not correct. The further a portfolio is from the parent, the less important it seems. Let's look at portfolio "D". 
# 1, A invests 41% of its total assets into D. 
# 2, D invests 70% into S.
# So we believe that that the impact of S is 0.41 * 0.7. 
# While in the same time we believe that the impact of D is 0.41.
# So which portfolio would you sign off first to have the biggest impact? 
# - Probably D...
# #### Is this really true? 
# D's impact is distorted as it is not normalized with the part it passes on. Basically we can't conclude that D has a 41% of impact on A, as D invest 70% into S. D on its own is responsible for only 30% of its own costs, the rest is coming from S, therefore the real impact of D is: 1-(total invested into funds) * weight. Which is in this example:
#  * D = 0.3*0.41 = 0.123
#  * S = 0.7*0.41 = 0.287
#  * So that 41% that A is holding in D does not belong to B solely but splits into two.
# 
# With the correct implementation, the code and the chart looks quite different:

# In[ ]:


node_information = []
weight_dictionary = nx.get_edge_attributes(G, 'weight')
total_fund_part_dictionary = nx.get_node_attributes(G,'total_fund_part')

if portfolio in total_fund_part_dictionary:
            p_fund_part = total_fund_part_dictionary[portfolio]
else:
            p_fund_part = 'Not Applicable'

for n in G.nodes():
    if nx.has_path(G, portfolio,n ) == True and n != portfolio:
        length = nx.shortest_path_length(G, portfolio,n)
        #collect all possible paths
        short_path = nx.shortest_path(G,portfolio,n)
        pathes = list(nx.all_simple_paths(G,portfolio,n))
        #loop through all possible pathes
        for everypath in pathes:
            edgelist = create_edgepairs(everypath)
        for i,edgepairs in enumerate(edgelist):
            if i ==0:
                port_impact = weight_dictionary[edgepairs[0],edgepairs[1]] * (1-G.node[n]['total_fund_part'])
            else:
                port_impact = port_impact * weight_dictionary[edgepairs[0],edgepairs[1]] * (1-G.node[n]['total_fund_part'])
               
        if len(list(G.successors(n))) == 0:
            leaf = 'Leaf - bottom portfolio'
        else:
            leaf = 'Parent portfolio'
        #check if value is in dictionary
        
        node_information.append([portfolio,n, G.node[n]['direct_cost'],p_fund_part,
                                 port_impact, length, leaf, short_path[1:]])

impact_frame = pd.DataFrame(node_information,columns=['portfolio','child','child_cost','total_fund_part',
                                              'port_impact','steps','position','short_path'])
impact_frame.head(16)


# In[ ]:


cost_portions = impact_frame.port_impact * impact_frame.child_cost
rcParams['figure.figsize'] = 10,8
colors = ['gold','yellowgreen','lightcoral','lightskyblue','lavender','lightpink',
          'aliceblue','palegoldenrod','lavenderblush','lightcyan','lightsalmon','lightblue']
explode = [0,0,0,0,0,0,0,0,0,0,0,0.1]
plt.pie(cost_portions,labels = impact_frame.child,colors=colors,
        shadow=True, 
        startangle = 291,explode = explode)
plt.title("Impact by portfolio",size=15)
plt.legend(round(impact_frame.port_impact * impact_frame.child_cost,2))
plt.axis('equal')
plt.show()


# <a id='Solution'></a>

# ## As it becomes more complex - deep dive into the recursive world
# 
# Until now, we managed to prioritise the funds, by assigning them the "PortImpact" attribute. However the aim is to calculate (or "not calculate") the actual cost of each portfolio within the graph. To achieve correct calculation results, we need to make sure, when we "flow the costs up", that only "assigned" costs will be inherited and we inform the users that we are missing a portion which is still unassigned. ("total_approved")
# 
# To do that:
# The variable "approved" needs to be split into two. 
# 1. Direct - this comes from the source file (this was the binary label which was set up to be 0 or 1)
# 2. Inherited this is calculated among the tree
# 3. *The total - which is the sum of the two in this logic should equal to 1 if everything is approved*
# 
# *It is a bit tricky to follow this part - as the direct inheritance is rather 1 or 0 (so basically recorded against the direct costs themselves) while the approved inheritance is recorded against the whole fund (for example a fund can have an approved inheritance of 0.55 if this is all that it can inherit (total_fund_part = 0.55) basically that is 100%, as it is a bit messy to follow I advise to follow the total_approved variable as that shows the best, what is going on within a fund. *

# # Implementation
# 
# I believe that here comes the fun part when we actually implement the recursive algorithm up in the tree, thus making sure "poisonous" costs are not getting further inherited within the graph. 
# I solved this in two different ways - 
# 1. The "Onion method" - Needs a copy of the original graph as it peels off the leaves one by one, until there is nothing left. 
# 2. Does not need a copy of the original graph however it is more difficult to follow how it works. 
# (this one is not included yet in this workbook)
# 
# 
# First of all we need to understand all the attributes we are starting the calculations with. 
# In the first initial state:
# 1. Every node is assigned 0 inherited cost (as this is calculated up in the graph)
# 2. The approved_inheritance is 0 as this is also calculated up in the graph
# 3. The total_approved which is set to (direct + approved)
# 4. Since leaves are at the bottom of the tree will not inherit anything it is easy to say that they are 100% assigned for 0, therefore setting approved_inheritance on them to 1. (This will have an important role in the following part)
# 5. Total costs at the starting positions are direct costs * whether we believe those costs are right
# 
# *There are other ways to capture the leaves within the graph - this might also be more performance friendly!
# Try the following code for the same results:*
# 
# ```python
#     leaves = [x for x in G.nodes() if G.out_degree(x)==0]
# ```
# 
# 
# 

# In[ ]:


leaves = []
F = G.subgraph(G).copy()

for eachnode in F.nodes():
    F.node[eachnode]['inherited_cost'] = 0
    F.node[eachnode]['approved_inheritance'] = 0
    F.node[eachnode]['total_approved'] = F.node[eachnode]['approved_inheritance'] + F.node[eachnode]['direct_approved']
    F.node[eachnode]['total_cost'] = F.node[eachnode]['direct_cost']*F.node[eachnode]['direct_approved']
    if list(F.successors(eachnode)) == []:
        leaves.append(eachnode)
        F.node[eachnode]['total_fund_part'] = 0
        F.node[eachnode]['approved_inheritance'] = 1   


# ## The Algorithm
# There are two very important things to consider within the graph:
# 1. Does the fund (which is investing) invest with a significant weight? 
# 2. How much is the total_approved attribute within the invested fund? 
# If the multiplication of these two exceed 95% we accept the node and let it send its costs further. 
# *(Obviously these thresholds are just made up for this demo, it could be set to 90% or whatever sensitivity we would like to assign to our model)*
# 
# The **counter** represents which level the portfolio is. Leaves are on level 1, as they are not further investing into anything, while everything above that, is assigned a number which represents how many steps need to be taken from the portfolio to arrive at the bottom of the graph.
# 
# The algorithm, sets up two empty lists. 
# OutL - this is a list where all the values are collected - storing the results.
# NextLevel - these will be new Leaves once the first layer of leaves is removed. 
# 
# ##### **Round 1 **:
#   1. Direct parents are collected
#   2. total_approved = direct_approved as a leaf has no inherited costs. 
#   So if weight * 1-total_approved is less than 5% we are happy (as if the weight is tiny probably it won't distort too much, of total costs - so we let it be inherited)
#   3. approved_inheritance is updated at the parent - as much as leaf can send
#   4. inherited_cost is updated (weight * leaf total cost)
#   5. total approved is updated
#   6. Total costs are updated
#     
#  The only thing we are sure about this point is the leaves, as those have received all information (basically in round 1) they didn't get anything, so we collect all the leaves into a list (OutL) with their most important attributes.
# 
# ##### **Round 2**
#   1. We remove all the leaves we had before, as they carry no more information and update the list with those nodes which used to be at level "2" these will be our new leaves.
#     *Note that not all the direct parents from the previous round will become leaves in this round*
#   2.From here it does make sense to check the total_approved variable, as it won't be rather 1 or 0, but something that was calculatd in the previous round.
#   3. Every leaf sends information a level up
#   4. Every leaf is appended to the list, then removed
#   5. The algorithm from here goes on, until we have no leaves in the list, as there is no parent to send costs up to. 
#     
# 
# *For further explanation on the algorithm see visualizations at the bottom of the kernel.*
# 
# ### Understanding the output:
#  * approved inheritance - how much of out of the total **fund** is signed off via fund investments. 
#  * direct_approved - rather we accept the initial costs of the fund
#  * total_approved - altogehter - how sure we are about the cost of the fund (direct + inherited)
# 
# 
#     

# In[ ]:


counter = 1
output = []
next_level = []
while leaves != []: #while the list of leaves is not empty
    for leaf in leaves:
        direct_parents = list(F.predecessors(leaf))     #get the list of the parents
        for eachpar in direct_parents:
            # send your weight * approval to parents
            if weight_dictionary[eachpar,leaf] * (1- (F.node[leaf]['total_approved'])) < 0.05:
                # update approved_inheritance to your existing + your child's total *weight
                F.node[eachpar]['approved_inheritance'] = F.node[eachpar]['approved_inheritance']  + weight_dictionary[eachpar,leaf]  * F.node[leaf]['total_approved']
                # update inherited cost to existings + your weight * child's cost
                F.node[eachpar]['inherited_cost'] =  F.node[eachpar]['inherited_cost'] + weight_dictionary[eachpar,leaf] * F.node[leaf]['total_cost']
                # update the total_approved of the parent
                F.node[eachpar]['total_approved'] = F.node[eachpar]['approved_inheritance'] + (1-F.node[eachpar]['total_fund_part'])*F.node[eachpar]['direct_approved']
                # update the total costs    
                F.node[eachpar]['total_cost'] = F.node[eachpar]['total_cost'] + weight_dictionary[eachpar,leaf] * F.node[leaf]['total_cost']
                
        output.append([leaf,
                     F.node[leaf]['approved_inheritance'],
                     F.node[leaf]['direct_approved'],
                     F.node[leaf]['total_approved'],
                     F.node[leaf]['inherited_cost'],
                     F.node[leaf]['direct_cost'],
                     F.node[leaf]['total_cost'],
                     counter,
                     F.node[leaf]['total_fund_part']]) #add the leaf to the list
        F.remove_node(leaf) #remove the leaf from the graph
    for eachnode in F.nodes():
        if list(F.successors(eachnode)) == []:  
            # identify all the bottom leaves again (these were parents in the last round)
                next_level.append(eachnode)
    leaves = next_level
    counter = counter + 1
    next_level = []
    #print('Check finished on level ' + str(counter))
df = pd.DataFrame(output, columns=['portfolio','approved_inheritance','direct_approved','total_approved',
                                 'inherited_cost','direct_cost','total_cost','counter','total_fund_inhertied'])

df


# <a id='Conclusions'></a>

# ## Further thoughts
# Above we implemented the algorithm, performed some additional analysis, but to check whether we are right or wrong, is quite cumbersome at this point. 
# The query below aims to help on that checking what has been done so far, collecting what is being set to which portfolio, on what reasons.  
# This example checks the costs, but obviously very similarly we could track every "flexible" attribute within the tree.
# (For example approved_inheritance)
# 

# In[ ]:


leaves = []

#create the "helper-graph" again

F = G.subgraph(G).copy()

for eachnode in F.nodes():
    F.node[eachnode]['inherited_cost'] = 0
    F.node[eachnode]['approved_inheritance'] = 0
    F.node[eachnode]['total_approved'] = F.node[eachnode]['approved_inheritance'] + F.node[eachnode]['direct_approved']
    F.node[eachnode]['total_cost'] = F.node[eachnode]['direct_cost']*F.node[eachnode]['direct_approved']
    if list(F.successors(eachnode)) == []:
        leaves.append(eachnode)
        F.node[eachnode]['total_fund_part'] = 0
        F.node[eachnode]['approved_inheritance'] = 1   

info = [[F.node["A"]['direct_cost'],"A",F.node["A"]['direct_cost']/(1-F.node["A"]['total_fund_part'])]]
checklist = []
next_level = []
while leaves != []: #while the list of leaves is not empty
    for leaf in leaves:
        direct_parents = list(F.predecessors(leaf))     #get the list of the parents
        for eachpar in direct_parents:
            if weight_dictionary[eachpar,leaf] * (1- (F.node[leaf]['total_approved'])) < 0.05:
                F.node[eachpar]['approved_inheritance'] = F.node[eachpar]['approved_inheritance'] + weight_dictionary[eachpar,leaf]  * F.node[leaf]['total_approved']
                inh_passed = weight_dictionary[eachpar,leaf]  * F.node[leaf]['total_approved']
                
                F.node[eachpar]['inherited_cost'] =  F.node[eachpar]['inherited_cost'] + weight_dictionary[eachpar,leaf] * F.node[leaf]['total_cost']
                
                F.node[eachpar]['total_approved'] = F.node[eachpar]['approved_inheritance'] + (1-F.node[eachpar]['total_fund_part'])*F.node[eachpar]['direct_approved']
                
                F.node[eachpar]['total_cost'] = F.node[eachpar]['total_cost'] + weight_dictionary[eachpar,leaf] * F.node[leaf]['total_cost']
                total_inh_passed =  weight_dictionary[eachpar,leaf] * F.node[leaf]['total_cost']
                
                checklist.append([eachpar +" received total cost from " + leaf + " a value of " + str(total_inh_passed)
                              + " and it is " + str(F.node[leaf]['total_approved']*100) + "% signed off and " 
                              + eachpar + " invests " + str(weight_dictionary[eachpar,leaf]) + " into it" ])
                if eachpar == portfolio:
                    info.append([total_inh_passed,leaf,total_inh_passed/weight_dictionary[eachpar,leaf]])
        F.remove_node(leaf) #remove the leaf from the graph
    for eachnode in F.nodes():
        if list(F.successors(eachnode)) == []:  
            # identify all the bottom leaves again (these were parents in the last round)
                next_level.append(eachnode)
    leaves = next_level
    next_level = []
checklist
info_frame = pd.DataFrame(info, columns=['cost_impact','fund','normalized cost impact'])
checklist


# In[ ]:


opacity = 0.9
colors = ['gold','yellowgreen','lightcoral','lightskyblue','lavender','lightsalmon']
rcParams['figure.figsize'] = 18,14
plt.subplot(2,2,1)
plt.bar(info_frame.fund, info_frame.cost_impact, color = colors, width = 0.8, alpha = opacity)
plt.title("Cost Impact on A by each portfolio",size=16)
plt.subplot(2,2,2)
plt.bar(info_frame.fund, info_frame['normalized cost impact'],color = colors, width = 0.8, alpha = opacity)
plt.title("Cost impact on A normalized by invested weight",size=16)
plt.show()


# <a id='Usecases'></a>

# ## What the two charts indicate above:
# If I was managing portfolio "A" I might start to worry, that according how little amount is invested direcly, I happen to have very hight costs comarped to my peers. I might not want to invest into "E" anymore, as it is a very expensive fund (unless it has very good performance (high returns)).
# Fund D seems big on the first chart as a significant portion of A is invested into it, on the other hand we can see that its costs are not significantly higher than other funds, when looking at normalized values. 

# ## Results
# From here we can track how each portfolio is contributing to the cost of one portfolio, we can decide whether we want to increase the sensitivity of the model or keep it as it is.
# Also there are further things to consider when analyzing a singificantly larger graph than this, for example which portfolios to sign off first to have the biggest impact in the whole graph, and so on. 
# 
# 
# ### Similar use cases:
# 
# * Water flow via valves 
# * Traffic and roads
# 
# 
# I hope you liked  this kernel! If so please upvote.

# ### *Some visualizations, of what the algorithm is trying to achieve, these were all made in Power Point, only for better understanding the problem. *
# 
# 

# ## First Scenario
# Costs stop at the very bottom
# ![1_s.png](attachment:1_s.png)

# ## Second Scenario
# Costs are wrong, but it doesn't affect the Parent at the top
# ![2_s.png](attachment:2_s.png)

# ## Third Scenario
# 
# Costs are wrong at the bottom, they get until a point, but then distortion becomes too big, to let them furhter go "up".
# ![s_3.png](attachment:s_3.png)
