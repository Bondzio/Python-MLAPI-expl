#!/usr/bin/env python
# coding: utf-8

# In[ ]:



{
   "schemaVersion": 2,
   "mediaType": "application/vnd.docker.distribution.manifest.v2+json",
   "config": {
      "mediaType": "application/vnd.docker.container.image.v1+json",
      "size": 21950,
      "digest": "sha256:c16ef0b15db40240d94643d8140d051318b7bda394e934737abb9bf602f4f94a"
   },
   "layers": [
      {
         "mediaType": "application/vnd.docker.image.rootfs.diff.tar.gzip",
         "size": 50382957,
         "digest": "sha256:7e2b2a5af8f65687add6d864d5841067e23bd435eb1a051be6fe1ea2384946b4"
      },
      {
         "mediaType": "application/vnd.docker.image.rootfs.diff.tar.gzip",
         "size": 222909892,
         "digest": "sha256:59c89b5f9b0c6d94c77d4c3a42986d420aaa7575ac65fcd2c3f5968b3726abfc"
      },
      {
         "mediaType": "application/vnd.docker.image.rootfs.diff.tar.gzip",
         "size": 195204532,
         "digest": "sha256:4017849f9f85133e68a4125e9679775f8e46a17dcdb8c2a52bbe72d0198f5e68"
      },
      {
         "mediaType": "application/vnd.docker.image.rootfs.diff.tar.gzip",
         "size": 1522,
         "digest": "sha256:c8b29d62979a416da925e526364a332b13f8d5f43804ae98964de2a60d47c17a"
      },
      {
         "mediaType": "application/vnd.docker.image.rootfs.diff.tar.gzip",
         "size": 717,
         "digest": "sha256:12004028a6a740ac35e69f489093b860968cc37b9668f65b1e2f61fd4c4ad25c"
      },
      {
         "mediaType": "application/vnd.docker.image.rootfs.diff.tar.gzip",
         "size": 247,
         "digest": "sha256:3f09b9a53dfb03fd34e35d43694c2d38656f7431efce0e6647c47efb5f7b3137"
      },
      {
         "mediaType": "application/vnd.docker.image.rootfs.diff.tar.gzip",
         "size": 408,
         "digest": "sha256:03ed58116b0cb733cc552dc89ef5ea122b6c5cf39ec467f6ad671dc0ba35db0c"
      },
      {
         "mediaType": "application/vnd.docker.image.rootfs.diff.tar.gzip",
         "size": 331594702,
         "digest": "sha256:7844554d9ef75bb3f1d224e166ed12561e78add339448c52a8e5679943b229f1"
      },
      {
         "mediaType": "application/vnd.docker.image.rootfs.diff.tar.gzip",
         "size": 112943238,
         "digest": "sha256:6db6199fec8df3d06191df55be7898c3e1a0b8389371dbb86591c6710e0429cb"
      },
      {
         "mediaType": "application/vnd.docker.image.rootfs.diff.tar.gzip",
         "size": 425,
         "digest": "sha256:b89ff65d69ce89fe9d05fe3acf9f89046a19eaed148e80a6e167b93e6dc26423"
      },
      {
         "mediaType": "application/vnd.docker.image.rootfs.diff.tar.gzip",
         "size": 5476,
         "digest": "sha256:d7a15e9b63f265b3f895e4c9f02533d105d9b277e411b93e81bb98972018d11a"
      },
      {
         "mediaType": "application/vnd.docker.image.rootfs.diff.tar.gzip",
         "size": 1952,
         "digest": "sha256:f40e3a2f47878ee1eae7a6b962bff3f7bb2c47baceacc04c3eb29412bb981298"
      },
      {
         "mediaType": "application/vnd.docker.image.rootfs.diff.tar.gzip",
         "size": 2483992161,
         "digest": "sha256:3ed1085f84930ef13f3e8c18f9d13d41d88d325d8d6f846112253f61243aaf8c"
      },
      {
         "mediaType": "application/vnd.docker.image.rootfs.diff.tar.gzip",
         "size": 466,
         "digest": "sha256:8d9c821c249ed71ff932287bb5fe694a97ed97f5fcb89a849f1fb4c4c03f506a"
      },
      {
         "mediaType": "application/vnd.docker.image.rootfs.diff.tar.gzip",
         "size": 75218874,
         "digest": "sha256:3817a8279af4449b7bd1dc3a7fb13596baa6f5eddd16e3bee5cf35f62198c2cd"
      },
      {
         "mediaType": "application/vnd.docker.image.rootfs.diff.tar.gzip",
         "size": 165683028,
         "digest": "sha256:47b7da0f101efeb432c2ece0ef44809ed0f3c7f5989f08e3bf46d85b1f61ed27"
      },
      {
         "mediaType": "application/vnd.docker.image.rootfs.diff.tar.gzip",
         "size": 220902982,
         "digest": "sha256:2b5f6d5258897b25efc731a1b5dd18a5f03bead0bca2761f7b60c9c5910391e7"
      },
      {
         "mediaType": "application/vnd.docker.image.rootfs.diff.tar.gzip",
         "size": 356442721,
         "digest": "sha256:bcef0d575f24bab55f4b78e26261a0fc2f4b1db4064187a11ff16f63199187eb"
      },
      {
         "mediaType": "application/vnd.docker.image.rootfs.diff.tar.gzip",
         "size": 1026874564,
         "digest": "sha256:fcecbd6c71f021ab549192ed2ccf2535dd139e612b31ec353d1c2786a140b59a"
      },
      {
         "mediaType": "application/vnd.docker.image.rootfs.diff.tar.gzip",
         "size": 1543,
         "digest": "sha256:011c305f2826021aed1e8e3f553c943b6a1625281abf79e9203bea898e220190"
      },
      {
         "mediaType": "application/vnd.docker.image.rootfs.diff.tar.gzip",
         "size": 903,
         "digest": "sha256:f232990e81c40c133d2739cc6fded58c655f96bbcbc4c325d4becb330416a3e4"
      },
      {
         "mediaType": "application/vnd.docker.image.rootfs.diff.tar.gzip",
         "size": 206,
         "digest": "sha256:1769091e9f6baab5269085f6a677005643dd36b09088e077eefa8a37fc0ee06c"
      },
      {
         "mediaType": "application/vnd.docker.image.rootfs.diff.tar.gzip",
         "size": 370,
         "digest": "sha256:eb6e19be571b59164f2fa921b6b9077543942020409d1a4aef330bae0c4d0ecb"
      },
      {
         "mediaType": "application/vnd.docker.image.rootfs.diff.tar.gzip",
         "size": 978,
         "digest": "sha256:51fc0f4f88025cd28de49c122ac93cc722b819da759ac65f9350c01fa566c1f4"
      },
      {
         "mediaType": "application/vnd.docker.image.rootfs.diff.tar.gzip",
         "size": 456,
         "digest": "sha256:08fcc8dc0a85425bdd1c1b2a299a2e945b366b22a33b24a04ee5b245a0fffd15"
      },
      {
         "mediaType": "application/vnd.docker.image.rootfs.diff.tar.gzip",
         "size": 529718853,
         "digest": "sha256:20b5e96f5c4cb2cf0f5010ac04554fedeb3de0140772e9e2ecd0dcc893f2c8eb"
      },
      {
         "mediaType": "application/vnd.docker.image.rootfs.diff.tar.gzip",
         "size": 74961466,
         "digest": "sha256:62d23e6795d98e855f127f928ccc762231f670411ed904db3bdd90de21c9b698"
      },
      {
         "mediaType": "application/vnd.docker.image.rootfs.diff.tar.gzip",
         "size": 292768,
         "digest": "sha256:1fa178d93774d87c604e8aee0c09993d70fc66cdc5b5a7fbe0a27fa274e488c1"
      },
      {
         "mediaType": "application/vnd.docker.image.rootfs.diff.tar.gzip",
         "size": 213,
         "digest": "sha256:3b750d3131677927566a27004987d187c603edca5694d159880c42c1854c0210"
      }
   ]
}
p


# In[ ]:


func Version() string


# In[ ]:


type Consumer struct {
	// Op is the Operation that is consuming the output of another operation.
	Op *Operation

	// Index is the index of the input within Op that the output of another
	// operation is connected to.
	Index int
}


# In[ ]:


func (p Consumer) DataType() DataType


# In[ ]:


func (p Consumer) Producer() Output


# In[ ]:


type Context struct {
	// contains filtered or unexported fields
}


# In[ ]:


func NewContext(options *ContextOptions) (*Context, error)


# In[ ]:


func (c *Context) ListDevices() ([]Device, error)


# In[ ]:


type ContextOptions struct {
	// Config is a binary-serialized representation of the
	// tensorflow.ConfigProto protocol message
	// (https://www.tensorflow.org/code/tensorflow/core/protobuf/config.proto).
	Config []byte

	// Sets the default execution mode
	Async bool
}


# In[ ]:


type DataType C.TF_DataType


# In[ ]:


const (
	Float      DataType = C.TF_FLOAT
	Double     DataType = C.TF_DOUBLE
	Int32      DataType = C.TF_INT32
	Uint32     DataType = C.TF_UINT32
	Uint8      DataType = C.TF_UINT8
	Int16      DataType = C.TF_INT16
	Int8       DataType = C.TF_INT8
	String     DataType = C.TF_STRING
	Complex64  DataType = C.TF_COMPLEX64
	Complex    DataType = C.TF_COMPLEX
	Int64      DataType = C.TF_INT64
	Uint64     DataType = C.TF_UINT64
	Bool       DataType = C.TF_BOOL
	Qint8      DataType = C.TF_QINT8
	Quint8     DataType = C.TF_QUINT8
	Qint32     DataType = C.TF_QINT32
	Bfloat16   DataType = C.TF_BFLOAT16
	Qint16     DataType = C.TF_QINT16
	Quint16    DataType = C.TF_QUINT16
	Uint16     DataType = C.TF_UINT16
	Complex128 DataType = C.TF_COMPLEX128
	Half       DataType = C.TF_HALF
)


# In[ ]:


type Device struct {
	Name, Type       string
	MemoryLimitBytes int64
}


# In[ ]:


func (d Device) String() string


# In[ ]:


type Graph struct {
	// contains filtered or unexported fields
}


# In[ ]:


func NewGraph() *Graph


# In[ ]:


func (g *Graph) AddGradients(prefix string, y []Output, x []Output, dx []Output) ([]Output, error)


# In[ ]:


func (g *Graph) AddOperation(args OpSpec) (*Operation, error)


# In[ ]:


func (g *Graph) Import(def []byte, prefix string) error


# In[ ]:


func (g *Graph) ImportWithOptions(def []byte, options GraphImportOptions) error


# In[ ]:


func (g *Graph) Operation(name string) *Operation


# In[ ]:


func (g *Graph) Operations() []Operation


# In[ ]:


func (g *Graph) WriteTo(w io.Writer) (int64, error)


# In[ ]:


type GraphImportOptions struct {
	// Node prefix
	Prefix string

	// Execution device
	Device string
}


# In[ ]:


type Input interface {
	// contains filtered or unexported methods
}


# In[ ]:


type OpSpec struct {
	// Type of the operation (e.g., "Add", "MatMul").
	Type string

	// Name by which the added operation will be referred to in the Graph.
	// If omitted, defaults to Type.
	Name string

	// Inputs to this operation, which in turn must be outputs
	// of other operations already added to the Graph.
	//
	// An operation may have multiple inputs with individual inputs being
	// either a single tensor produced by another operation or a list of
	// tensors produced by multiple operations. For example, the "Concat"
	// operation takes two inputs: (1) the dimension along which to
	// concatenate and (2) a list of tensors to concatenate. Thus, for
	// Concat, len(Input) must be 2, with the first element being an Output
	// and the second being an OutputList.
	Input []Input

	// Map from attribute name to its value that will be attached to this
	// operation.
	Attrs map[string]interface{}

	// Operations that must be executed before executing the operation
	// being added.
	ControlDependencies []*Operation

	// The device on which the operation should be executed.
	// If omitted, an appropriate device will automatically be selected.
	//
	// For example, if set of "/device:GPU:0", then the operation will
	// execute on GPU #0.
	Device string
}


# In[ ]:


type Operation struct {
	// contains filtered or unexported fields
}


# In[ ]:


func (op *Operation) Attr(name string) (interface{}, error)


# In[ ]:


func (op *Operation) Device() string


# In[ ]:


func (op *Operation) Name() string


# In[ ]:


func (op *Operation) NumInputs() int


# In[ ]:


func (op *Operation) NumOutputs() int


# In[ ]:


func (op *Operation) Output(i int) Output


# In[ ]:


func (op *Operation) OutputListSize(output string) (int, error)


# In[ ]:


func (op *Operation) Type() string


# In[ ]:


type Output struct {
	// Op is the Operation that produces this Output.
	Op *Operation

	// Index specifies the index of the output within the Operation.
	Index int
}


# In[ ]:


func (p Output) Consumers() []Consumer


# In[ ]:


func (p Output) DataType() DataType


# In[ ]:


func (p Output) Shape() Shape


# In[ ]:


type OutputList []Output


# In[ ]:


type PartialRun struct {
	// contains filtered or unexported fields
}

