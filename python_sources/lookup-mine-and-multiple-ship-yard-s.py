#!/usr/bin/env python
# coding: utf-8

# In[ ]:


get_ipython().run_cell_magic('writefile', 'submission.py', '\nglobal MinDistance\nglobal targets\nglobal globalShipState\nglobal changeDirection\nglobal halite2objectsRatioA\nglobal scruteArea\nglobal minHaliteToMove\nglobal factorToMove\ntargets={}\nglobalShipState={}\n\n\nscruteArea=6\nminDistance=8\nhalite2objectsRatio =1800\nminHaliteToMove=40 \nfactorToMove=2\n\n####################\n# Helper functions #\n####################\n\n# Helper function we\'ll use for getting adjacent position with the most halite\ndef argmax(arr, key=None):\n    return arr.index(max(arr, key=key)) if key else arr.index(max(arr))\n\n# Converts position from 1D to 2D representation\ndef get_col_row(size, pos):\n    return (pos % size, pos // size)\n\n# Returns the position in some direction relative to the current position (pos) \ndef get_to_pos(size, pos, direction):\n    col, row = get_col_row(size, pos)\n    if direction == "NORTH":\n        return pos - size if pos >= size else size ** 2 - size + col\n    elif direction == "SOUTH":\n        return col if pos + size >= size ** 2 else pos + size\n    elif direction == "EAST":\n        return pos + 1 if col < size - 1 else row * size\n    elif direction == "WEST":\n        return pos - 1 if col > 0 else (row + 1) * size - 1\n\n# Get positions in all directions relative to the current position (pos)\n# Especially useful for figuring out how much halite is around you\ndef getAdjacent(pos, size):\n    return [\n        get_to_pos(size, pos, "NORTH"),\n        get_to_pos(size, pos, "SOUTH"),\n        get_to_pos(size, pos, "EAST"),\n        get_to_pos(size, pos, "WEST"),\n    ]\n\ndef check_cell(j, i, game_map, player, size, debug=False):\n    occupied = False\n    ennemy=None\n    cargo=0\n    pos=i*size+j\n    if debug:\n        print(game_map[j%size][i%size]["ship"])\n    #print ("shipyard : ", game_map[j%size][i%size]["shipyard"], " at ", pos, "(x,y)", j, i)\n    #if game_map[j%size][i%size]["shipyard"]!=None and game_map[j%size][i%size]["shipyard"]!=0: print ("shipyard : ", game_map[j%size][i%size]["shipyard"], " at ", pos, "(x,y)", j, i)\n    if game_map[j%size][i%size]["ship"]!= None and  game_map[j%size][i%size]["ship"]!=player:\n        ennemy="ship"\n        cargo=game_map[j%size][i%size]["ship_cargo"]\n        occupied=True\n    if game_map[j%size][i%size]["shipyard"]!= None and game_map[j%size][i%size]["shipyard"]!=player:\n        ennemy="shipyard"\n        #print("found ennemy shipyard at ", j, i, "means", i*size+j)\n        occupied=True\n    if game_map[j%size][i%size]["ship"]!= None and  game_map[j%size][i%size]["ship"]==player:\n        ennemy="self"\n        print("self at ", pos, j, i)\n        occupied=True\n    return ennemy, cargo\n\n# Returns best direction to move from one position (fromPos) to another (toPos)\n# Example: If I\'m at pos 0 and want to get to pos 55, which direction should I choose?\ndef getDirTo(fromPos, toPos, game_map,player, size):\n    fromY, fromX = divmod(fromPos, size)\n    toY,   toX   =  divmod(toPos,   size)\n    nennemy, ncargo=check_cell(fromX,fromY-1, game_map, player, size )\n    sennemy, scargo=check_cell(fromX,fromY+1, game_map, player, size )\n    eennemy, ecargo=check_cell(fromX+1,fromY, game_map, player, size )\n    wennemy, wcargo=check_cell(fromX-1,fromY, game_map, player, size )\n    #print(nennemy, sennemy , eennemy, wennemy)\n    if (toY-fromY)%size < (fromY-toY)%size :\n        if (sennemy=="ship" and scargo>game_map[fromX][fromY]["ship_cargo"]) or sennemy==None:\n            return "SOUTH"\n        else: return "ENNEMY"\n    if (toY-fromY)%size > (fromY-toY)%size :\n        if (nennemy=="ship" and ncargo>game_map[fromX][fromY]["ship_cargo"]) or nennemy==None:\n            return "NORTH"\n        else: return "ENNEMY"\n    if (toX-fromX)%size < (fromX-toX)%size :\n        if (eennemy=="ship" and ecargo>game_map[fromX][fromY]["ship_cargo"]) or eennemy==None:\n            return "EAST"\n        else: return "ENNEMY"\n    if (toX-fromX)%size > (fromX-toX)%size :\n        if (wennemy=="ship" and wcargo>game_map[fromX][fromY]["ship_cargo"]) or wennemy==None:\n            return "WEST"\n        else: return "ENNEMY"\n        \n    \n\n# Possible directions a ship can move in\nDIRS = ["NORTH", "SOUTH", "EAST", "WEST"]\n# We\'ll use this to keep track of whether a ship is collecting halite or \n# carrying its cargo to a shipyard\nship_states = {}\n\n\n#########\n# distance\n#########\n\ndef distance(currPos, targetPos, size):\n    currX, currY=divmod(currPos, size)\n    targetX, targetY=divmod(targetPos, size)\n    diffX=abs(targetX-currX)%size\n    diffY=abs(targetY-currY)%size\n    \n    return diffX+diffY\n\n\n\n##################\n#scrutinize\n#################\n\ndef scrutinize(currPos, radius, game_map,player, size):\n    currY, currX=divmod(currPos, size)\n    #print("CurrX {1} CurrY {2} Radius {2} size {4}", currX, currY, radius, size)\n    maxHalite=0\n    xmax=(currX)%size\n    ymax=(currY)%size\n    for i in range(currY-radius, currY+radius):\n        for j in range(currX-radius, currX+radius):\n            #print(game_map[j][i]["halite"])\n            if game_map[j%size][i%size]["halite"] > maxHalite:\n                if game_map[j%size][i%size]["shipyard"] == None and game_map[j%size][i%size]["ship"]== None:\n                    xmax=j%size\n                    ymax=i%size\n                    maxHalite=game_map[j%size][i%size]["halite"]\n            if game_map[j%size][i%size]["ship"]!= None and  game_map[j%size][i%size]["ship"]!=player and game_map[j%size][i%size]["shipyard"]== None:\n                cargo=game_map[j%size][i%size]["ship_cargo"]\n                if cargo>maxHalite and cargo > game_map[currX%size][currY%size]["ship_cargo"]:\n                    xmax=j%size\n                    ymax=i%size\n                    maxHalite=cargo\n        \n    #print (currPos,ymax*size+xmax,  xmax, ymax, maxHalite)            \n    return ymax*size+xmax, maxHalite\n\ndef detect_ennemy(pos, game_map, player, status, direction, size):\n    fromX, fromY =divmod(pos, size)\n    newdir=None\n    playerhalite=game_map[fromX][fromY]["ship_cargo"]\n    if playerhalite==None: playerhalite=0\n    staticAction={"ENNEMY": {"NORTH": "SOUTH", "WEST": "EAST", "EAST": "WEST", "SOUTH": "NORTH"}, "SELF": "NOTHING"}\n    movingAction={"ENNEMY": {"NORTH": "SOUTH", "WEST": "EAST", "EAST": "WEST", "SOUTH": "NORTH"}, \n                  "SELF": {"NORTH": "SOUTH", "WEST": "EAST", "EAST": "WEST", "SOUTH": "NORTH"}}\n    i=0\n    if status != "MOVING":\n        nennemy, ncargo=check_cell(fromX,fromY-1, game_map, player, size, True )\n        sennemy, scargo=check_cell(fromX,fromY+1, game_map, player, size, True)\n        eennemy, ecargo=check_cell(fromX+1,fromY, game_map, player, size, True )\n        wennemy, wcargo=check_cell(fromX-1,fromY, game_map, player, size, True )\n        \n        if ncargo == None: ncargo=0\n        if scargo == None: scargo=0\n        if ecargo == None: ecargo=0\n        if wcargo == None: wcargo=0    \n            \n        if nennemy =="ship" and ncargo<playerhalite:\n            newdir="SOUTH"\n            i+=1\n        if sennemy  =="ship" and scargo<playerhalite:\n            newdir="ship"\n            i+=1\n        if wennemy  =="ship" and wcargo<playerhalite:\n            newdir="EAST"\n            i+=1\n        if eennemy  =="ship" and ecargo<playerhalite:\n            newdir="WEST"\n            i+=1\n        print(sennemy, wennemy, eennemy, nennemy)\n    else:\n        if direction == "NORTH":\n            NEennemy, cargo=check_cell(fromX-1,fromY-1, game_map, player, size )\n            NWennemy, cargo=check_cell(fromX+1,fromY-1, game_map, player, size )\n            Nennemy, cargo=check_cell(fromX,fromY-2, game_map, player, size )\n            print("***", NEennemy, NWennemy, Nennemy)\n            if "ship" in (NEennemy, NWennemy, Nennemy):# or "self" in (NEennemy, NWennemy, Nennemy):\n                newdir="SOUTH"\n                \n        if direction == "WEST":\n            SWennemy, cargo=check_cell(fromX-1,fromY+1, game_map, player, size )\n            NWennemy, cargo=check_cell(fromX-1,fromY-1, game_map, player, size )\n            Wennemy, cargo=check_cell(fromX-2,fromY, game_map, player, size )\n            if "ship" in (Wennemy, NWennemy, SWennemy):# or "self"  in (Wennemy, NWennemy, SWennemy):\n                newdir="EAST"\n        if direction == "EAST":\n            NEennemy, cargo=check_cell(fromX+1,fromY-1, game_map, player, size )\n            SEennemy, cargo=check_cell(fromX+1,fromY+1, game_map, player, size )\n            Eennemy, cargo=check_cell(fromX+2,fromY, game_map, player, size )\n            if "ship" in (NEennemy, SEennemy, Eennemy):# or "self" in (NEennemy, SEennemy, Eennemy):\n                newdir="WEST"\n        if direction == "SOUTH":\n            SEennemy, cargo=check_cell(fromX+1,fromY+1, game_map, player, size )\n            SWennemy, cargo=check_cell(fromX-1,fromY+1, game_map, player, size )\n            Sennemy, cargo=check_cell(fromX,fromY+2, game_map, player, size )\n            if "ship" in (SEennemy, SWennemy, Sennemy):# or "self" in (SEennemy, SWennemy, Sennemy):\n                newdir="NORTH"            \n        print(direction, newdir, cargo)\n    if i>1: \n        newdir="CONVERT"\n        print("Convert")\n    else:\n        if newdir != None:\n            print(newdir)\n    \n    return newdir \n    \n\ndef get_map(obs, conf):\n    # define map\n    game_map = []\n    for x in range(conf.size):\n        game_map.append([])\n        for y in range(conf.size):\n            game_map[x].append({\n                # value will be ID of owner\n                "shipyard": None,\n                # value will be ID of owner\n                "ship": None,\n                # value will be amount of halite\n                "ship_cargo": None,\n                # amount of halite\n                "halite": obs.halite[conf.size * y + x]})\n\n    # place ships and shipyards on the map\n    for player in range(len(obs.players)):\n        shipyards = list(obs.players[player][1].values())\n        for shipyard in shipyards:\n            x = shipyard % conf.size\n            y = shipyard // conf.size\n            # place shipyard on the map            \n            game_map[x][y]["shipyard"] = player\n            #print(game_map[x][y]["shipyard"])\n\n        ships = list(obs.players[player][2].values())\n        for ship in ships:\n            x = ship[0] % conf.size\n            y = ship[0] // conf.size\n            # place ship on the map\n            game_map[x][y]["ship"] = player\n            game_map[x][y]["ship_cargo"] = ship[1]\n    return game_map\n\n\n#############\n# The agent #\n#############\n\ndef agent(obs, config):\n    global globalShipState\n    global targets \n    \n    \n    \n    # Get the player\'s halite, shipyard locations, and ships (along with cargo) \n    player_halite, shipyards, ships = obs.players[obs.player]\n    size = config["size"]\n    # Initialize a dictionary containing commands that will be sent to the game\n    action = {}\n    #print(list(obs.players[0][2].values())[0][0])\n    \n    \n    mymap=get_map(obs, config)\n    MaxPos={}\n    MaxHalite={}\n    #if len(ships)>0:\n    #    scrute=round(scruteArea/len(ships))\n    #    if scrute==0: scrute=1\n    \n    \n    # If there are no ships, use first shipyard to spawn a ship.\n    if len(ships) == 0 and len(shipyards) > 0:\n        uid = list(shipyards.keys())[-1]\n        action[uid] = "SPAWN"\n    else:\n        if (obs.step%3==0) and (obs.step<150) and (player_halite/(len(ships)+len(shipyards))>halite2objectsRatio) and len(shipyards) > 0:\n            # if far enough from the farthest shipyard from any ship then convert into shipyard \n            farthest=0\n            i=0\n            for shippos in list(shipyards.values()):                \n                closest=size**2\n                for shipypos in list(ships.values()):\n                    spos=shipypos[1]\n                    if distance(spos, shippos, size) < closest:                        \n                        closest=distance(spos, shippos, size)                            \n                        \n                if closest > farthest:\n                    farthest=closest\n                    indfar=i\n                i+=1                    \n            \n            uid = list(shipyards.keys())[indfar]\n            action[uid] = "SPAWN"\n        \n    # If there are no shipyards, convert first ship into shipyard.\n    if len(shipyards) == 0 and len(ships) > 0:\n        uid = list(ships.keys())[0]\n        #print (list(ships.values())[0][0])\n        action[uid] = "CONVERT"\n        globalShipState[uid]="CONVERTING"\n        ship_states[uid]="NOTHING"\n\n    #if obs.step%10==0: print(obs.step) \n    for uid, ship in ships.items():\n        \n        if uid not in action: # Ignore ships that will be converted to shipyards\n            pos, cargo = ship # Get the ship\'s position and halite in cargo\n            print("pos ", pos)\n            #print("uid before assignment", uid)\n            if not (uid in globalShipState):\n                globalShipState[uid]=\'COLLECTING\'\n                #print("changed ", uid,  "COLLECTING")\n            ### check the sheep needs to move\n            #print("global ship after assignment", globalShipState[uid])\n            ### Part 1: Set the ship\'s state \n            if cargo < 500: # If cargo is too low, collect halite\n                if globalShipState[uid]==\'DEPOSITING\':\n                    #because if it is < 500 means it is not depositing any more\n                    globalShipState[uid]=\'COLLECTING\'\n                    #print ("will global ship state still be depositing ?")\n                if globalShipState[uid]==\'COLLECTING\':\n                    # keep the global status collecting unless there\'s a significantly\n                    # bigger amount of halite in the neibourhood\n                    currHalite= obs.halite[pos]\n                    MaxPos[uid], MaxHalite[uid]=scrutinize(list(ships.values())[0][0], scruteArea, mymap, obs.player, config.size)\n                    if MaxHalite[uid]>minHaliteToMove+currHalite*factorToMove:\n                        \n                        globalShipState[uid]=\'MOVING\'\n                        #print("pos is ",pos, "moving to ", MaxPos[uid])\n                        targets[uid]=MaxPos[uid]\n                ship_states[uid] = "COLLECT"\n                if globalShipState[uid]==\'ESCAPING\':\n                    ship_states[uid] = "DEPOSIT"\n                    \n           \n                \n            if cargo >= 500: # If cargo gets very big, deposit halite\n                \n                # if far enough from the closest shipyard then convert into shipyard \n                closest=size**2\n                i=0                \n                for shipypos in list(shipyards.values()):\n                    if distance(pos, shipypos, size) < closest:\n                        closest=distance(pos, shipypos, size)\n                        indshyp=i\n                    i+=1\n                \n                if ((obs.step<200) and (distance(pos, list(shipyards.values())[indshyp], size) > minDistance and player_halite / (len(ships)+len(shipyards))>3*halite2objectsRatio) and len(shipyards)<=len(ships)) or (globalShipState[uid]==\'CONVERTING\'):\n                    action[uid] = "CONVERT"\n                else:\n                    ship_states[uid] = "DEPOSIT"\n                \n            ### Part 2: Use the ship\'s state to select an action\n            if ship_states[uid] == "COLLECT":\n                # if global status is moving go to the target defined in the current turn or in previous turns\n                if globalShipState[uid]==\'MOVING\':\n                    newPos=getDirTo(list(ships.values())[0][0], targets[uid], mymap, obs.player, config.size)\n                    #print (newPos)\n                    if newPos!="ENNEMY" and newPos!=None:\n                        newDirection=detect_ennemy(pos, mymap, obs.player, "MOVING", newPos, size)\n                        if newDirection: \n                            print("change from static to", newPos, newDirection)\n                            globalShipState[uid]=\'ESCAPING\'\n                            newPos=newDirection\n                        \n                        action[uid]=newPos\n                    else:\n                        if newPos=="ENNEMY":\n                            #print("Danger change from to deposit", obs.step)\n                            ship_states[uid] = "DEPOSIT"\n                            globalShipState[uid]=\'COLLECTING\'\n                    if newPos==None:\n                        globalShipState[uid]=\'LANDING\'\n                else:\n                    if globalShipState[uid]==\'LANDING\':\n                        globalShipState[uid]=\'COLLECTING\'\n                    newDirection=detect_ennemy(pos, mymap, obs.player, "COLLECTING", "NORTH", size)\n                    if globalShipState==\'ESCAPING\':\n                        currHalite= obs.halite[pos]\n                        MaxPos[uid], MaxHalite[uid]=scrutinize(list(ships.values())[0][0], scruteArea, mymap, obs.player, config.size)\n                        newDirection=getDirTo(pos, MaxPos[uid], mymap, obs.player, config.size)\n                    if newDirection: print("tag2", newDirection)\n                    if newDirection: \n                        #print("change from static to", newDirection)\n                        action[uid]=newDirection\n                        globalShipState[uid]=\'MOVING\'\n            \n            if ship_states[uid] == "DEPOSIT":\n                if globalShipState[uid] !=\'DEPOSITING\':\n                    # Move towards the closest shipyard to deposit cargo\n                    closest=size**2\n                    i=0\n                    for shipypos in list(shipyards.values()):\n                        if distance(pos, shipypos, size) < closest:\n                            closest=distance(pos, shipypos, size)\n                            indshyp=i-1\n                        i+=1\n                    targets[uid]=list(shipyards.values())[indshyp]\n                    globalShipState[uid] =\'DEPOSITING\'\n                    direction = getDirTo(pos, targets[uid], mymap, obs.player, size)\n                    #print("setting to DEPOSITING to  ", targets[uid])\n                else:\n                    #print("Status already in DEPOSITING setting direction to  ", targets[uid])\n                    direction = getDirTo(pos, targets[uid], mymap, obs.player, size)\n                \n                if direction!="ENNEMY" and direction!=None:\n                    newDirection=detect_ennemy(pos, mymap, obs.player, "MOVING", direction, size)\n                    \n                    if newDirection:\n                        #print ("new direction recommended", newDirection)\n                        direction = newDirection\n                    action[uid] = direction\n                    #print("have to deposit towards ", pos, obs.step)\n                else:\n                    if direction=="ENNEMY":\n                        #print("Change to collecting", obs.step)\n                        globalShipState[uid]=\'CONVERTING\'\n                        action[uid] ="CONVERT"\n\n    #print ("at", obs.step, "status", globalShipState)    \n    return action\n        ')


# In[ ]:


get_ipython().run_cell_magic('writefile', 'correct2.py', '\nglobal MinDistance\nglobal targets\nglobal globalShipState\nglobal changeDirection\nglobal halite2objectsRatio\nglobal scruteArea\nglobal minHaliteToMove\nglobal factorToMove\ntargets={}\nglobalShipState={}\n\nscruteArea=4\nminDistance=8\nhalite2objectsRatio =1500\nminHaliteToMove=200 \nfactorToMove=1.5\n####################\n# Helper functions #\n####################\n\n# Helper function we\'ll use for getting adjacent position with the most halite\ndef argmax(arr, key=None):\n    return arr.index(max(arr, key=key)) if key else arr.index(max(arr))\n\n# Converts position from 1D to 2D representation\ndef get_col_row(size, pos):\n    return (pos % size, pos // size)\n\n# Returns the position in some direction relative to the current position (pos) \ndef get_to_pos(size, pos, direction):\n    col, row = get_col_row(size, pos)\n    if direction == "NORTH":\n        return pos - size if pos >= size else size ** 2 - size + col\n    elif direction == "SOUTH":\n        return col if pos + size >= size ** 2 else pos + size\n    elif direction == "EAST":\n        return pos + 1 if col < size - 1 else row * size\n    elif direction == "WEST":\n        return pos - 1 if col > 0 else (row + 1) * size - 1\n\n# Get positions in all directions relative to the current position (pos)\n# Especially useful for figuring out how much halite is around you\ndef getAdjacent(pos, size):\n    return [\n        get_to_pos(size, pos, "NORTH"),\n        get_to_pos(size, pos, "SOUTH"),\n        get_to_pos(size, pos, "EAST"),\n        get_to_pos(size, pos, "WEST"),\n    ]\n\ndef check_cell(j, i, game_map, player, size):\n    occupied = False\n    ennemy=None\n    cargo=0\n    pos=i*size+j\n    #print(game_map[j%size][i%size])\n    #print ("shipyard : ", game_map[j%size][i%size]["shipyard"], " at ", pos, "(x,y)", j, i)\n    #if game_map[j%size][i%size]["shipyard"]!=None and game_map[j%size][i%size]["shipyard"]!=0: print ("shipyard : ", game_map[j%size][i%size]["shipyard"], " at ", pos, "(x,y)", j, i)\n    if game_map[j%size][i%size]["ship"]!= None and  game_map[j%size][i%size]["ship"]!=player:\n        ennemy="ship"\n        cargo=game_map[j%size][i%size]["ship_cargo"]\n        occupied=True\n    if game_map[j%size][i%size]["shipyard"]!= None and game_map[j%size][i%size]["shipyard"]!=player:\n        ennemy="shipyard"\n        #print("found ennemy shipyard at ", j, i, "means", i*size+j)\n        occupied=True\n    if game_map[j%size][i%size]["ship"]!= None and  game_map[j%size][i%size]["ship"]==player:\n        ennemy="self"\n        occupied=True\n    return ennemy, cargo\n\n# Returns best direction to move from one position (fromPos) to another (toPos)\n# Example: If I\'m at pos 0 and want to get to pos 55, which direction should I choose?\ndef getDirTo(fromPos, toPos, game_map,player, size):\n    fromY, fromX = divmod(fromPos, size)\n    toY,   toX   =  divmod(toPos,   size)\n    nennemy, ncargo=check_cell(fromX,fromY-1, game_map, player, size )\n    sennemy, scargo=check_cell(fromX,fromY+1, game_map, player, size )\n    eennemy, ecargo=check_cell(fromX+1,fromY, game_map, player, size )\n    wennemy, wcargo=check_cell(fromX-1,fromY, game_map, player, size )\n    #print(nennemy, sennemy , eennemy, wennemy)\n    if (toY-fromY)%size < (fromY-toY)%size :\n        if (sennemy=="ship" and scargo>game_map[fromX][fromY]["ship_cargo"]) or sennemy==None:\n            return "SOUTH"\n        else: return "ENNEMY"\n    if (toY-fromY)%size > (fromY-toY)%size :\n        if (nennemy=="ship" and ncargo>game_map[fromX][fromY]["ship_cargo"]) or nennemy==None:\n            return "NORTH"\n        else: return "ENNEMY"\n    if (toX-fromX)%size < (fromX-toX)%size :\n        if (eennemy=="ship" and ecargo>game_map[fromX][fromY]["ship_cargo"]) or eennemy==None:\n            return "EAST"\n        else: return "ENNEMY"\n    if (toX-fromX)%size > (fromX-toX)%size :\n        if (wennemy=="ship" and wcargo>game_map[fromX][fromY]["ship_cargo"]) or wennemy==None:\n            return "WEST"\n        else: return "ENNEMY"\n        \n    \n\n# Possible directions a ship can move in\nDIRS = ["NORTH", "SOUTH", "EAST", "WEST"]\n# We\'ll use this to keep track of whether a ship is collecting halite or \n# carrying its cargo to a shipyard\nship_states = {}\n\n\n#########\n# distance\n#########\n\ndef distance(currPos, targetPos, size):\n    currX, currY=divmod(currPos, size)\n    targetX, targetY=divmod(targetPos, size)\n    diffX=abs(targetX-currX)%size\n    diffY=abs(targetY-currY)%size\n    \n    return diffX+diffY\n\n\n\n##################\n#scrutinize\n#################\n\ndef scrutinize(currPos, radius, game_map,player, size):\n    currY, currX=divmod(currPos, size)\n    #print("CurrX {1} CurrY {2} Radius {2} size {4}", currX, currY, radius, size)\n    maxHalite=0\n    xmax=(currX)%size\n    ymax=(currY)%size\n    for i in range(currY-radius, currY+radius):\n        for j in range(currX-radius, currX+radius):\n            #print(game_map[j][i]["halite"])\n            if game_map[j%size][i%size]["halite"] > maxHalite:\n                if game_map[j%size][i%size]["shipyard"] == None and game_map[j%size][i%size]["ship"]== None:\n                    xmax=j%size\n                    ymax=i%size\n                    maxHalite=game_map[j%size][i%size]["halite"]\n            if game_map[j%size][i%size]["ship"]!= None and  game_map[j%size][i%size]["ship"]!=player and game_map[j%size][i%size]["shipyard"]== None:\n                cargo=game_map[j%size][i%size]["ship_cargo"]\n                if cargo>maxHalite and cargo > game_map[currX%size][currY%size]["ship_cargo"]:\n                    xmax=j%size\n                    ymax=i%size\n                    maxHalite=cargo\n        \n    #print (currPos,ymax*size+xmax,  xmax, ymax, maxHalite)            \n    return ymax*size+xmax, maxHalite\n\ndef get_map(obs, conf):\n    # define map\n    game_map = []\n    for x in range(conf.size):\n        game_map.append([])\n        for y in range(conf.size):\n            game_map[x].append({\n                # value will be ID of owner\n                "shipyard": None,\n                # value will be ID of owner\n                "ship": None,\n                # value will be amount of halite\n                "ship_cargo": None,\n                # amount of halite\n                "halite": obs.halite[conf.size * y + x]})\n\n    # place ships and shipyards on the map\n    for player in range(len(obs.players)):\n        shipyards = list(obs.players[player][1].values())\n        for shipyard in shipyards:\n            x = shipyard % conf.size\n            y = shipyard // conf.size\n            # place shipyard on the map            \n            game_map[x][y]["shipyard"] = player\n            #print(game_map[x][y]["shipyard"])\n\n        ships = list(obs.players[player][2].values())\n        for ship in ships:\n            x = ship[0] % conf.size\n            y = ship[0] // conf.size\n            # place ship on the map\n            game_map[x][y]["ship"] = player\n            game_map[x][y]["ship_cargo"] = ship[1]\n    return game_map\n\n\n#############\n# The agent #\n#############\n\ndef agent(obs, config):\n    global globalShipState\n    global targets \n    \n    \n    \n    # Get the player\'s halite, shipyard locations, and ships (along with cargo) \n    player_halite, shipyards, ships = obs.players[obs.player]\n    size = config["size"]\n    # Initialize a dictionary containing commands that will be sent to the game\n    action = {}\n    #print(list(obs.players[0][2].values())[0][0])\n    \n    \n    mymap=get_map(obs, config)\n    MaxPos={}\n    MaxHalite={}\n    #if len(ships)>0:\n    #    scrute=round(scruteArea/len(ships))\n    #    if scrute==0: scrute=1\n    \n    \n    # If there are no ships, use first shipyard to spawn a ship.\n    if len(ships) == 0 and len(shipyards) > 0:\n        uid = list(shipyards.keys())[-1]\n        action[uid] = "SPAWN"\n    else:\n        if (obs.step%30==0) and (obs.step<250) and (player_halite/(len(ships)+len(shipyards))>halite2objectsRatio) and len(shipyards) > 0:\n            # if far enough from the farthest shipyard from any ship then convert into shipyard \n            farthest=0\n            i=0\n            for shippos in list(shipyards.values()):                \n                closest=size**2\n                for shipypos in list(ships.values()):\n                    spos=shipypos[1]\n                    if distance(spos, shippos, size) < closest:                        \n                        closest=distance(spos, shippos, size)                            \n                        \n                if closest > farthest:\n                    farthest=closest\n                    indfar=i\n                i+=1                    \n            \n            uid = list(shipyards.keys())[indfar]\n            action[uid] = "SPAWN"\n        \n    # If there are no shipyards, convert first ship into shipyard.\n    if len(shipyards) == 0 and len(ships) > 0:\n        uid = list(ships.keys())[0]\n        #print (list(ships.values())[0][0])\n        action[uid] = "CONVERT"\n        globalShipState[uid]="CONVERTING"\n        ship_states[uid]="NOTHING"\n\n    #if obs.step%10==0: print(obs.step) \n    for uid, ship in ships.items():\n        \n        if uid not in action: # Ignore ships that will be converted to shipyards\n            pos, cargo = ship # Get the ship\'s position and halite in cargo\n            #print("uid before assignment", uid)\n            if not (uid in globalShipState):\n                globalShipState[uid]=\'NEW\'\n                #print("changed ", uid,  "COLLECTING")\n            ### check the sheep needs to move\n            #print("global ship after assignment", globalShipState[uid])\n            ### Part 1: Set the ship\'s state \n            if cargo < 500: # If cargo is too low, collect halite\n                if globalShipState[uid]==\'DEPOSITING\':\n                    #because if it is < 500 means it is not depositing any more\n                    globalShipState[uid]=\'COLLECTING\'\n                    #print ("will global ship state still be depositing ?")\n                if globalShipState[uid] in [\'COLLECTING\', \'NEW\']:\n                    # keep the global status collecting unless there\'s a significantly\n                    # bigger amount of halite in the neibourhood\n                    if globalShipState[uid]:\n                        currHalite= obs.halite[pos]\n                    else:\n                        currHalite=0\n                    MaxPos[uid], MaxHalite[uid]=scrutinize(list(ships.values())[0][0], scruteArea, mymap, obs.player, config.size)\n                    if MaxHalite[uid]>minHaliteToMove+currHalite*factorToMove:\n                        \n                        globalShipState[uid]=\'MOVING\'\n                        #print("pos is ",pos, "moving to ", MaxPos[uid])\n                        targets[uid]=MaxPos[uid]\n                ship_states[uid] = "COLLECT"\n                    \n           \n                \n            if cargo >= 500: # If cargo gets very big, deposit halite\n                \n                # if far enough from the closest shipyard then convert into shipyard \n                closest=size**2\n                i=0                \n                for shipypos in list(shipyards.values()):\n                    if distance(pos, shipypos, size) < closest:\n                        closest=distance(pos, shipypos, size)\n                        indshyp=i\n                    i+=1\n                \n                if ((obs.step<200) and (distance(pos, list(shipyards.values())[indshyp], size) > minDistance and player_halite / (len(ships)+len(shipyards))>2*halite2objectsRatio) and len(shipyards)<=len(ships)) or (globalShipState[uid]==\'CONVERTING\'):\n                    action[uid] = "CONVERT"\n                else:\n                    ship_states[uid] = "DEPOSIT"\n                \n            ### Part 2: Use the ship\'s state to select an action\n            if ship_states[uid] == "COLLECT":\n                # if global status is moving go to the target defined in the current turn or in previous turns\n                if globalShipState[uid]==\'MOVING\':\n                    newPos=getDirTo(list(ships.values())[0][0], targets[uid], mymap, obs.player, config.size)\n                    #print (newPos)\n                    if newPos!="ENNEMY" and newPos!=None:\n                        action[uid]=newPos\n                    else:\n                        if newPos=="ENNEMY":\n                            #print("Danger change from to deposit", obs.step)\n                            ship_states[uid] = "DEPOSIT"\n                            globalShipState[uid]=\'COLLECTING\'\n                    if newPos==None:\n                        globalShipState[uid]=\'LANDING\'\n                else:\n                    if globalShipState[uid]==\'LANDING\':\n                        globalShipState[uid]=\'COLLECTING\'\n\n            \n            if ship_states[uid] == "DEPOSIT":\n                if globalShipState[uid] !=\'DEPOSITING\':\n                    # Move towards the closest shipyard to deposit cargo\n                    closest=size**2\n                    i=0\n                    for shipypos in list(shipyards.values()):\n                        if distance(pos, shipypos, size) < closest:\n                            closest=distance(pos, shipypos, size)\n                            indshyp=i-1\n                        i+=1\n                    targets[uid]=list(shipyards.values())[indshyp]\n                    globalShipState[uid] =\'DEPOSITING\'\n                    direction = getDirTo(pos, targets[uid], mymap, obs.player, size)\n                    #print("setting to DEPOSITING to  ", targets[uid])\n                else:\n                    #print("Status already in DEPOSITING setting direction to  ", targets[uid])\n                    direction = getDirTo(pos, targets[uid], mymap, obs.player, size)\n                \n                if direction!="ENNEMY" and direction!=None:                     \n                    action[uid] = direction\n                    #print("have to deposit towards ", pos, obs.step)\n                else:\n                    if direction=="ENNEMY":\n                        \n                        #print("Change to collecting", obs.step)\n                        globalShipState[uid]=\'CONVERTING\'\n\n    #print ("at", obs.step, "status", globalShipState)    \n    return action\n        ')


# In[ ]:


get_ipython().run_cell_magic('writefile', '"best.py"', '\nglobal MinDistance\nglobal targets\nglobal globalShipState\nglobal changeDirection\nglobal halite2objectsRatio\nglobal scruteArea\nglobal minHaliteToMove\nglobal factorToMove\ntargets={}\nglobalShipState={}\n\nscruteArea=3\nminDistance=8\nhalite2objectsRatio =1800\nminHaliteToMove=150 \nfactorToMove=1.5\n####################\n# Helper functions #\n####################\n\n# Helper function we\'ll use for getting adjacent position with the most halite\ndef argmax(arr, key=None):\n    return arr.index(max(arr, key=key)) if key else arr.index(max(arr))\n\n# Converts position from 1D to 2D representation\ndef get_col_row(size, pos):\n    return (pos % size, pos // size)\n\n# Returns the position in some direction relative to the current position (pos) \ndef get_to_pos(size, pos, direction):\n    col, row = get_col_row(size, pos)\n    if direction == "NORTH":\n        return pos - size if pos >= size else size ** 2 - size + col\n    elif direction == "SOUTH":\n        return col if pos + size >= size ** 2 else pos + size\n    elif direction == "EAST":\n        return pos + 1 if col < size - 1 else row * size\n    elif direction == "WEST":\n        return pos - 1 if col > 0 else (row + 1) * size - 1\n\n# Get positions in all directions relative to the current position (pos)\n# Especially useful for figuring out how much halite is around you\ndef getAdjacent(pos, size):\n    return [\n        get_to_pos(size, pos, "NORTH"),\n        get_to_pos(size, pos, "SOUTH"),\n        get_to_pos(size, pos, "EAST"),\n        get_to_pos(size, pos, "WEST"),\n    ]\n\ndef check_cell(j, i, game_map, player, size):\n    occupied = False\n    ennemy=None\n    cargo=0\n    pos=i*size+j\n    #print(game_map[j%size][i%size])\n    #print ("shipyard : ", game_map[j%size][i%size]["shipyard"], " at ", pos, "(x,y)", j, i)\n    #if game_map[j%size][i%size]["shipyard"]!=None and game_map[j%size][i%size]["shipyard"]!=0: print ("shipyard : ", game_map[j%size][i%size]["shipyard"], " at ", pos, "(x,y)", j, i)\n    if game_map[j%size][i%size]["ship"]!= None and  game_map[j%size][i%size]["ship"]!=player:\n        ennemy="ship"\n        cargo=game_map[j%size][i%size]["ship_cargo"]\n        occupied=True\n    if game_map[j%size][i%size]["shipyard"]!= None and game_map[j%size][i%size]["shipyard"]!=player:\n        ennemy="shipyard"\n        print("found ennemy shipyard at ", j, i, "means", i*size+j)\n        occupied=True\n    if game_map[j%size][i%size]["ship"]!= None and  game_map[j%size][i%size]["ship"]==player:\n        ennemy="self"\n        occupied=True\n    return ennemy, cargo\n\n# Returns best direction to move from one position (fromPos) to another (toPos)\n# Example: If I\'m at pos 0 and want to get to pos 55, which direction should I choose?\ndef getDirTo(fromPos, toPos, game_map,player, size):\n    fromY, fromX = divmod(fromPos, size)\n    toY,   toX   =  divmod(toPos,   size)\n    nennemy, ncargo=check_cell(fromX,fromY-1, game_map, player, size )\n    sennemy, scargo=check_cell(fromX,fromY+1, game_map, player, size )\n    eennemy, ecargo=check_cell(fromX+1,fromY, game_map, player, size )\n    wennemy, wcargo=check_cell(fromX-1,fromY, game_map, player, size )\n    #print(nennemy, sennemy , eennemy, wennemy)\n    if (toY-fromY)%size < (fromY-toY)%size :\n        if (sennemy=="ship" and scargo>game_map[fromX][fromY]["ship_cargo"]) or sennemy==None:\n            return "SOUTH"\n        else: return "ENNEMY"\n    if (toY-fromY)%size > (fromY-toY)%size :\n        if (nennemy=="ship" and ncargo>game_map[fromX][fromY]["ship_cargo"]) or nennemy==None:\n            return "NORTH"\n        else: return "ENNEMY"\n    if (toX-fromX)%size < (fromX-toX)%size :\n        if (eennemy=="ship" and ecargo>game_map[fromX][fromY]["ship_cargo"]) or eennemy==None:\n            return "EAST"\n        else: return "ENNEMY"\n    if (toX-fromX)%size > (fromX-toX)%size :\n        if (wennemy=="ship" and wcargo>game_map[fromX][fromY]["ship_cargo"]) or wennemy==None:\n            return "WEST"\n        else: return "ENNEMY"\n        \n    \n\n# Possible directions a ship can move in\nDIRS = ["NORTH", "SOUTH", "EAST", "WEST"]\n# We\'ll use this to keep track of whether a ship is collecting halite or \n# carrying its cargo to a shipyard\nship_states = {}\n\n\n#########\n# distance\n#########\n\ndef distance(currPos, targetPos, size):\n    currX, currY=divmod(currPos, size)\n    targetX, targetY=divmod(targetPos, size)\n    diffX=abs(targetX-currX)%size\n    diffY=abs(targetY-currY)%size\n    \n    return diffX+diffY\n\n\n\n##################\n#scrutinize\n#################\n\ndef scrutinize(currPos, radius, game_map,player, size):\n    currY, currX=divmod(currPos, size)\n    #print("CurrX {1} CurrY {2} Radius {2} size {4}", currX, currY, radius, size)\n    maxHalite=0\n    xmax=(currX)%size\n    ymax=(currY)%size\n    for i in range(currY-radius, currY+radius):\n        for j in range(currX-radius, currX+radius):\n            #print(game_map[j][i]["halite"])\n            if game_map[j%size][i%size]["halite"] > maxHalite:\n                if game_map[j%size][i%size]["shipyard"] == None and game_map[j%size][i%size]["ship"]== None:\n                    xmax=j%size\n                    ymax=i%size\n                    maxHalite=game_map[j%size][i%size]["halite"]\n            if game_map[j%size][i%size]["ship"]!= None and  game_map[j%size][i%size]["ship"]!=player and game_map[j%size][i%size]["shipyard"]== None:\n                cargo=game_map[j%size][i%size]["ship_cargo"]\n                if cargo>maxHalite and cargo > game_map[currX%size][currY%size]["ship_cargo"]:\n                    xmax=j%size\n                    ymax=i%size\n                    maxHalite=cargo\n        \n    #print (currPos,ymax*size+xmax,  xmax, ymax, maxHalite)            \n    return ymax*size+xmax, maxHalite\n\ndef get_map(obs, conf):\n    # define map\n    game_map = []\n    for x in range(conf.size):\n        game_map.append([])\n        for y in range(conf.size):\n            game_map[x].append({\n                # value will be ID of owner\n                "shipyard": None,\n                # value will be ID of owner\n                "ship": None,\n                # value will be amount of halite\n                "ship_cargo": None,\n                # amount of halite\n                "halite": obs.halite[conf.size * y + x]})\n\n    # place ships and shipyards on the map\n    for player in range(len(obs.players)):\n        shipyards = list(obs.players[player][1].values())\n        for shipyard in shipyards:\n            x = shipyard % conf.size\n            y = shipyard // conf.size\n            # place shipyard on the map            \n            game_map[x][y]["shipyard"] = player\n            print(game_map[x][y]["shipyard"])\n\n        ships = list(obs.players[player][2].values())\n        for ship in ships:\n            x = ship[0] % conf.size\n            y = ship[0] // conf.size\n            # place ship on the map\n            game_map[x][y]["ship"] = player\n            game_map[x][y]["ship_cargo"] = ship[1]\n    return game_map\n\n\n#############\n# The agent #\n#############\n\ndef agent(obs, config):\n    global globalShipState\n    global targets \n    \n    \n    \n    # Get the player\'s halite, shipyard locations, and ships (along with cargo) \n    player_halite, shipyards, ships = obs.players[obs.player]\n    size = config["size"]\n    # Initialize a dictionary containing commands that will be sent to the game\n    action = {}\n    #print(list(obs.players[0][2].values())[0][0])\n    \n    \n    mymap=get_map(obs, config)\n    MaxPos={}\n    MaxHalite={}\n    #if len(ships)>0:\n    #    scrute=round(scruteArea/len(ships))\n    #    if scrute==0: scrute=1\n    \n    \n    # If there are no ships, use first shipyard to spawn a ship.\n    if len(ships) == 0 and len(shipyards) > 0:\n        uid = list(shipyards.keys())[-1]\n        action[uid] = "SPAWN"\n    else:\n        if (obs.step%30==0) and (obs.step<200) and (player_halite/(len(ships)+len(shipyards))>halite2objectsRatio) and len(shipyards) > 0:\n            # if far enough from the farthest shipyard from any ship then convert into shipyard \n            farthest=0\n            i=0\n            for shippos in list(shipyards.values()):                \n                closest=size**2\n                for shipypos in list(ships.values()):\n                    spos=shipypos[1]\n                    if distance(spos, shippos, size) < closest:                        \n                        closest=distance(spos, shippos, size)                            \n                        \n                if closest > farthest:\n                    farthest=closest\n                    indfar=i\n                i+=1                    \n            \n            uid = list(shipyards.keys())[indfar]\n            action[uid] = "SPAWN"\n        \n    # If there are no shipyards, convert first ship into shipyard.\n    if len(shipyards) == 0 and len(ships) > 0:\n        uid = list(ships.keys())[0]\n        #print (list(ships.values())[0][0])\n        action[uid] = "CONVERT"\n        globalShipState[uid]="CONVERTING"\n        ship_states[uid]="NOTHING"\n\n    #if obs.step%10==0: print(obs.step) \n    for uid, ship in ships.items():\n        \n        if uid not in action: # Ignore ships that will be converted to shipyards\n            pos, cargo = ship # Get the ship\'s position and halite in cargo\n            #print("uid before assignment", uid)\n            if not (uid in globalShipState):\n                globalShipState[uid]=\'COLLECTING\'\n                #print("changed ", uid,  "COLLECTING")\n            ### check the sheep needs to move\n            #print("global ship after assignment", globalShipState[uid])\n            ### Part 1: Set the ship\'s state \n            if cargo < 500: # If cargo is too low, collect halite\n                if globalShipState[uid]==\'DEPOSITING\':\n                    #because if it is < 500 means it is not depositing any more\n                    globalShipState[uid]=\'COLLECTING\'\n                    print ("will global ship state still be depositing ?")\n                if globalShipState[uid]==\'COLLECTING\':\n                    # keep the global status collecting unless there\'s a significantly\n                    # bigger amount of halite in the neibourhood\n                    currHalite= obs.halite[pos]\n                    MaxPos[uid], MaxHalite[uid]=scrutinize(list(ships.values())[0][0], scruteArea, mymap, obs.player, config.size)\n                    if MaxHalite[uid]>minHaliteToMove+currHalite*factorToMove:\n                        \n                        globalShipState[uid]=\'MOVING\'\n                        #print("pos is ",pos, "moving to ", MaxPos[uid])\n                        targets[uid]=MaxPos[uid]\n                ship_states[uid] = "COLLECT"\n                    \n           \n                \n            if cargo >= 500: # If cargo gets very big, deposit halite\n                \n                # if far enough from the closest shipyard then convert into shipyard \n                closest=size**2\n                i=0                \n                for shipypos in list(shipyards.values()):\n                    if distance(pos, shipypos, size) < closest:\n                        closest=distance(pos, shipypos, size)\n                        indshyp=i\n                    i+=1\n                \n                if ((obs.step<200) and (distance(pos, list(shipyards.values())[indshyp], size) > minDistance and player_halite / (len(ships)+len(shipyards))>2*halite2objectsRatio) and len(shipyards)<=len(ships)) or (globalShipState[uid]==\'CONVERTING\'):\n                    action[uid] = "CONVERT"\n                else:\n                    ship_states[uid] = "DEPOSIT"\n                \n            ### Part 2: Use the ship\'s state to select an action\n            if ship_states[uid] == "COLLECT":\n                # if global status is moving go to the target defined in the current turn or in previous turns\n                if globalShipState[uid]==\'MOVING\':\n                    newPos=getDirTo(list(ships.values())[0][0], targets[uid], mymap, obs.player, config.size)\n                    #print (newPos)\n                    if newPos!="ENNEMY" and newPos!=None:\n                        action[uid]=newPos\n                    else:\n                        if newPos=="ENNEMY":\n                            print("Danger change from to deposit", obs.step)\n                            ship_states[uid] = "DEPOSIT"\n                            globalShipState[uid]=\'COLLECTING\'\n                    if newPos==None:\n                        globalShipState[uid]=\'LANDING\'\n                else:\n                    if globalShipState[uid]==\'LANDING\':\n                        globalShipState[uid]=\'COLLECTING\'\n\n            \n            if ship_states[uid] == "DEPOSIT":\n                if globalShipState[uid] !=\'DEPOSITING\':\n                    # Move towards the closest shipyard to deposit cargo\n                    closest=size**2\n                    i=0\n                    for shipypos in list(shipyards.values()):\n                        if distance(pos, shipypos, size) < closest:\n                            closest=distance(pos, shipypos, size)\n                            indshyp=i-1\n                        i+=1\n                    targets[uid]=list(shipyards.values())[indshyp]\n                    globalShipState[uid] =\'DEPOSITING\'\n                    direction = getDirTo(pos, targets[uid], mymap, obs.player, size)\n                    #print("setting to DEPOSITING to  ", targets[uid])\n                else:\n                    #print("Status already in DEPOSITING setting direction to  ", targets[uid])\n                    direction = getDirTo(pos, targets[uid], mymap, obs.player, size)\n                \n                if direction!="ENNEMY" and direction!=None:                     \n                    action[uid] = direction\n                    #print("have to deposit towards ", pos, obs.step)\n                else:\n                    if direction=="ENNEMY":\n                        \n                        print("Change to collecting", obs.step)\n                        globalShipState[uid]=\'CONVERTING\'\n\n    #print ("at", obs.step, "status", globalShipState)    \n    return action\n        ')


# In[ ]:


from kaggle_environments import make, evaluate
env = make("halite", debug=True)

env.run(["submission.py", "correct2.py", "best.py", "best.py"])
env.render(mode="ipython", width=480, height=360)


# In[ ]:




