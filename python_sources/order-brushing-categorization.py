#!/usr/bin/env python
# coding: utf-8

# In[ ]:


get_ipython().run_cell_magic('time', '', '\nimport pandas as pd\nimport os\nfrom getpass import getuser\nfrom datetime import datetime\n\nfile_path = ""\nfor dirname, _, filenames in os.walk(\'/kaggle/input\'):\n    for filename in filenames:\n        file_path = os.path.join(dirname, filename)\n\n# convert event_time column from string to datetime object\ndata[\'event_time\'] = pd.to_datetime(data[\'event_time\'])\n\n# sort by seller, buyer, and date - This is important for the following operation\ndata.sort_values(by=[\'shopid\', \'userid\', \'event_time\'], ascending=True, inplace=True)\n\n# Convert datetime to UNIX format (number of seconds since 1970/01/01)\ndata[\'seconds\'] = (data[\'event_time\'] - datetime(1970, 1, 1)).dt.total_seconds()\ndata.reset_index(drop=True, inplace=True)\n\nkeys = data[[\'shopid\', \'userid\']].copy()\n\n# Features #1: interval_hour = True if 3 transactions is made consecutively in 1 hour range\ninterval1 = data[\'seconds\'].diff(1).fillna(0)\ninterval2 = data[\'seconds\'].diff(2).fillna(0)\n\nseparator1 = (keys != keys.shift(1)).sum(axis=1) > 0\nseparator2 = (keys != keys.shift(2)).sum(axis=1) > 0\n\ninterval1[separator1] = 0 \ninterval2[separator2] = 0 \n\ndata[\'interval_hour\'] = (interval1 <= 3600) & (interval2 <= 3600)\n\n# Features #2: batch_order = True if both parties are the same for 3 rows consecutively\nshift1 = (keys == keys.shift(1)).sum(axis=1) == 2\nshift2 = (keys == keys.shift(2)).sum(axis=1) == 2\ndata[\'batch_order\'] = shift1 & shift2\n\ndata[\'brush_order\'] = (data[\'interval_hour\']) & (data[\'batch_order\'])\nbrushing = data.loc[data[\'brush_order\'], [\'shopid\', \'userid\']]\nbrushing.drop_duplicates(inplace=True)\nbrushing[\'userid\'] = brushing[\'userid\'].astype(str)\nbrushing_result = brushing.groupby(\'shopid\').agg(lambda x: "&".join(x))\n\nresult = pd.DataFrame(data= data[\'shopid\'].unique(), columns=[\'shopid\'])\nresult = result.merge(brushing_result, left_on=\'shopid\', right_index=True, how=\'left\').fillna("0")\n\n# Get the top transactions from the potential order brushing user\nfor idx, shop, user_ids in result[result[\'userid\'].str.count(\'&\') > 1].itertuples(True, None):\n    user_ids = user_ids.split("&")\n    score_per_user = data[(data.userid.isin(user_ids)) & (data.shopid==shop)].groupby(\'userid\')[\'batch_order\'].sum()\n    userid = \'&\'.join(map(str,score_per_user[score_per_user == score_per_user.max()].index))\n    result.at[idx, \'userid\'] = userid\n    \nresult = result.applymap(str)\nresult.to_csv(\'mysubmission.csv\', index=False)\nprint(\'End of program\')')

